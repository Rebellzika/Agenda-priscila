<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minha Nova Agenda Pro</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body, html {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* Dark background */
            color: #e5e7eb; /* Light text */
            overscroll-behavior-y: contain; /* Prevent body scroll when modal is open */
        }
        .modal-overlay { background-color: rgba(0, 0, 0, 0.75); }
        .modal-content { background-color: #1f2937; animation: fadeInScaleModal 0.3s ease-out forwards; }
        @keyframes fadeInScaleModal {
            from { opacity: 0; transform: translateY(20px) scale(0.98); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
        .toast-container { position: fixed; top: 1.5rem; right: 1.5rem; z-index: 1000; }
        .toast { animation: slideInRightToast 0.4s ease-out forwards, fadeOutToast 0.4s ease-in forwards 3.6s; }
        @keyframes slideInRightToast { from { transform: translateX(120%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes fadeOutToast { from { opacity: 1; } to { opacity: 0; transform: translateX(120%);} }

        /* Custom scrollbar for dark theme */
        ::-webkit-scrollbar { width: 8px; height: 8px; } /* Mais fino para mobile */
        ::-webkit-scrollbar-track { background: #1f2937; border-radius: 10px; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }

        /* Date picker icon color for dark theme */
        input[type="date"]::-webkit-calendar-picker-indicator,
        input[type="time"]::-webkit-calendar-picker-indicator {
            filter: invert(0.8) brightness(100%);
        }
        .fc .fc-button-primary {
            background-color: #374151 !important;
            border-color: #4b5563 !important;
            color: #e5e7eb !important;
            font-size: 0.875rem !important; /* Ajuste de fonte para botões do calendário */
            padding: 0.5em 0.75em !important; /* Ajuste de padding */
        }
        .fc .fc-button-primary:hover, .fc .fc-button-primary:focus, .fc .fc-button-primary:active {
            background-color: #4b5563 !important;
            outline: none !important;
            box-shadow: none !important;
        }
        .fc .fc-daygrid-day-number, .fc .fc-col-header-cell-cushion {
            color: #d1d5db !important;
            font-size: 0.8rem; /* Menor em mobile */
        }
        @media (min-width: 640px) { /* sm breakpoint */
            .fc .fc-daygrid-day-number, .fc .fc-col-header-cell-cushion {
                 font-size: 0.9rem;
            }
        }

        .fc-theme-standard .fc-list-day-text, .fc-theme-standard .fc-list-day-side-text {
             color: #d1d5db !important;
        }
        .fc .fc-list-event:hover td {
            background-color: #374151 !important;
        }
        .fc-event {
            border: 1px solid #0a0a0a !important; /* Darker border for events */
            font-size: 0.75em; /* Mais legível em mobile */
            cursor: pointer; /* Indica que o evento é clicável */
        }
        .fc-daygrid-day.fc-day-today {
            background-color: rgba(75, 85, 99, 0.3) !important; /* bg-gray-600 with opacity */
        }
        .fc-day.fc-daygrid-day.calendar-day-selected { 
            background-color: rgba(99, 102, 241, 0.2) !important; 
        }
        .fc-event-main {
            padding: 2px 4px;
        }
        .fc-event-title {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .modal-content {
            max-height: 90vh;
            overflow-y: auto;
        }
        .countdown-timer, .tracked-time-display {
            font-size: 0.8em; 
            font-weight: 500;
            padding: 2px 6px; 
            border-radius: 4px; 
            margin-left: 0.25rem; /* Reduzir margem em mobile */
        }
        @media (min-width: 640px) { /* sm breakpoint */
            .countdown-timer, .tracked-time-display {
                font-size: 0.85em;
                padding: 3px 8px;
                border-radius: 6px;
                margin-left: 8px;
            }
        }
        .pulsate {
            animation: pulsateAnimation 1.5s infinite ease-in-out;
        }
        @keyframes pulsateAnimation {
            0% { opacity: 1; }
            50% { opacity: 0.6; }
            100% { opacity: 1; }
        }
        .day-of-week-checkbox-group label {
            display: inline-flex;
            align-items: center;
            margin-right: 8px; /* Ajuste para mobile */
            font-size: 0.875rem; /* text-sm */
            cursor: pointer;
        }
        .day-of-week-checkbox-group input[type="checkbox"] {
            margin-right: 3px;
             accent-color: #6366f1; /* Indigo */
        }
         @media (min-width: 640px) { /* sm breakpoint */
            .day-of-week-checkbox-group label {
                margin-right: 10px;
                font-size: inherit;
            }
             .day-of-week-checkbox-group input[type="checkbox"] {
                margin-right: 4px;
            }
        }
        .completed-tasks-container {
            max-height: 250px; /* Reduzir altura em mobile */
            overflow-y: auto;
        }
         @media (min-width: 768px) { /* md breakpoint */
            .completed-tasks-container {
                max-height: 300px;
            }
        }
        /* Estilos para o pop-up de ações rápidas do calendário */
        #calendarEventQuickActions {
            position: absolute;
            background-color: #1f2937; 
            border: 1px solid #4b5563; 
            border-radius: 0.5rem; 
            padding: 0.75rem; 
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); 
            z-index: 1050; 
            min-width: 200px; /* Ajustado para mobile */
        }
        #calendarEventQuickActions button {
            display: flex; 
            align-items: center; 
            width: 100%;
            text-align: left;
            padding: 0.5rem 0.75rem; 
            margin-bottom: 0.5rem; 
            font-size: 0.875rem; 
            color: #e5e7eb; 
            border-radius: 0.375rem; 
        }
        #calendarEventQuickActions button i { 
            margin-right: 0.5rem; 
            width: 1.25rem; 
            text-align: center;
        }
        #calendarEventQuickActions button:hover {
            background-color: #374151; 
        }
        #calendarEventQuickActions button:last-child {
            margin-bottom: 0;
        }
        #calendarEventQuickActions .quick-action-title {
            font-size: 1rem; 
            font-weight: 600; 
            color: #9ca3af; 
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #374151; 
            max-width: 250px; 
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        /* Ajustes para o cabeçalho em telas menores */
        header .container {
            flex-direction: column;
        }
        @media (min-width: 640px) { /* sm */
             header .container {
                flex-direction: row;
            }
        }
        /* Ajuste para o layout principal em telas menores */
        main .grid {
            grid-template-columns: 1fr; /* Coluna única por padrão */
        }
        @media (min-width: 1024px) { /* lg */
             main .grid {
                grid-template-columns: repeat(3, minmax(0, 1fr)); /* Volta para 3 colunas em telas grandes */
            }
            main .lg\\:col-span-1 {
                grid-column: span 1 / span 1;
            }
            main .lg\\:col-span-2 {
                grid-column: span 2 / span 2;
            }
        }


    </style>
    <!-- FullCalendar CDN -->
    <script src='https://cdn.jsdelivr.net/npm/fullcalendar@6.1.11/index.global.min.js'></script>
    <script src='https://cdn.jsdelivr.net/npm/@fullcalendar/core/locales/pt-br.global.js'></script>

</head>
<body class="flex flex-col min-h-screen">

    <!-- Overlay de Carregamento Global -->
    <div id="loadingOverlay" class="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-[1000] transition-opacity duration-300 opacity-0 pointer-events-none">
        <div class="flex flex-col items-center">
            <i class="fas fa-circle-notch fa-spin fa-3x text-indigo-400"></i>
            <p class="mt-4 text-indigo-300 text-lg font-medium">Carregando...</p>
        </div>
    </div>

    <!-- Container para Toasts (Notificações) -->
    <div id="toastContainer" class="toast-container"></div>

    <!-- Seção de Autenticação -->
    <div id="authSection" class="flex flex-grow items-center justify-center p-4">
        <div class="bg-gray-800 p-8 sm:p-10 rounded-xl shadow-2xl w-full max-w-md transform transition-all duration-300">
            <h2 class="text-3xl font-bold text-center text-indigo-400 mb-8">Agenda Pro</h2>
            <div class="space-y-6">
                <div>
                    <label for="email" class="block text-sm font-medium text-gray-300 mb-1">Email</label>
                    <input type="email" id="email" autocomplete="email" class="mt-1 block w-full px-4 py-3 bg-gray-700 border border-gray-600 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-white placeholder-gray-400" placeholder="seu.email@exemplo.com">
                </div>
                <div>
                    <label for="password" class="block text-sm font-medium text-gray-300 mb-1">Senha</label>
                    <input type="password" id="password" autocomplete="current-password" class="mt-1 block w-full px-4 py-3 bg-gray-700 border border-gray-600 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-white placeholder-gray-400" placeholder="Sua senha">
                </div>
                <button id="authButton" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white py-3 px-4 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 focus:ring-offset-gray-800 transition-all duration-150 ease-in-out font-semibold text-lg transform hover:scale-105">
                    Entrar
                </button>
                <!-- REMOVIDO: <p class="text-center text-sm text-gray-400"> Não tem conta? <button id="switchToRegisterButton" class="font-medium text-indigo-400 hover:text-indigo-300">Registre-se</button> </p> -->
            </div>
            <p id="authError" class="text-red-400 text-sm mt-4 text-center hidden"></p>
        </div>
    </div>

    <!-- Seção Principal da Agenda -->
    <div id="agendaSection" class="flex flex-col flex-grow hidden">
        <header class="bg-gray-800 shadow-md p-4 sticky top-0 z-50">
            <div class="container mx-auto flex flex-col sm:flex-row justify-between items-center">
                <h1 class="text-2xl font-bold text-indigo-400 mb-2 sm:mb-0">Minha Agenda Pro</h1>
                <div class="flex items-center space-x-2 sm:space-x-4">
                    <span id="userEmailDisplay" class="text-xs sm:text-sm text-gray-300 truncate max-w-[150px] sm:max-w-xs" title=""></span>
                    <button id="logoutButton" class="bg-red-600 hover:bg-red-700 text-white px-3 py-1.5 sm:px-4 sm:py-2 rounded-lg shadow-md text-sm font-medium transition-colors">
                        <i class="fas fa-sign-out-alt sm:mr-2"></i><span class="hidden sm:inline">Sair</span>
                    </button>
                </div>
            </div>
        </header>

        <main class="flex-grow container mx-auto p-3 sm:p-4 md:p-6">
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-4 md:gap-6">
                <!-- Coluna de Controles e Adicionar Tarefa -->
                <div class="lg:col-span-1 space-y-6">
                    <div class="bg-gray-800 p-4 sm:p-6 rounded-xl shadow-lg">
                        <h2 class="text-xl font-semibold text-indigo-400 mb-4">Adicionar Tarefa</h2>
                        <form id="addTaskForm" class="space-y-4">
                            <div>
                                <label for="taskTitle" class="block text-sm font-medium text-gray-300">Título <span class="text-red-400">*</span></label>
                                <input type="text" id="taskTitle" required class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm py-2 px-3 focus:ring-indigo-500 focus:border-indigo-500 text-white">
                            </div>
                             <div>
                                <label for="taskClient" class="block text-sm font-medium text-gray-300">Cliente</label>
                                <input type="text" id="taskClient" class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm py-2 px-3 focus:ring-indigo-500 focus:border-indigo-500 text-white">
                            </div>
                            <div>
                                <label for="taskType" class="block text-sm font-medium text-gray-300">Tipo</label>
                                <input type="text" id="taskType" class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm py-2 px-3 focus:ring-indigo-500 focus:border-indigo-500 text-white" placeholder="Ex: Reunião, Pagamento">
                            </div>
                            <div>
                                <label for="taskPriority" class="block text-sm font-medium text-gray-300">Prioridade</label>
                                <select id="taskPriority" class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm py-2 px-3 focus:ring-indigo-500 focus:border-indigo-500 text-white">
                                    <option value="low" class="bg-gray-700">Baixa</option>
                                    <option value="medium" selected class="bg-gray-700">Média</option>
                                    <option value="high" class="bg-gray-700">Alta</option>
                                    <option value="urgent" class="bg-gray-700">Urgente</option>
                                </select>
                            </div>
                            <div>
                                <label for="taskEstimatedTime" class="block text-sm font-medium text-gray-300">Tempo Estimado (min) <span class="text-red-400">*</span></label>
                                <input type="number" id="taskEstimatedTime" min="1" required class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm py-2 px-3 focus:ring-indigo-500 focus:border-indigo-500 text-white">
                            </div>
                            
                            <!-- Recurrence Options -->
                            <div class="flex items-center">
                                <input type="checkbox" id="taskIsRecurring" class="h-4 w-4 text-indigo-600 border-gray-500 rounded focus:ring-indigo-500">
                                <label for="taskIsRecurring" class="ml-2 block text-sm text-gray-300">Tarefa Recorrente</label>
                            </div>

                            <div id="recurrenceDetails" class="hidden space-y-3 pl-6 border-l-2 border-gray-700 ml-2">
                                <div>
                                    <label for="taskRecurrenceStartDate" class="block text-sm font-medium text-gray-300">Data de Início da Recorrência <span class="text-red-400">*</span></label>
                                    <input type="date" id="taskRecurrenceStartDate" class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm py-2 px-3 focus:ring-indigo-500 focus:border-indigo-500 text-white">
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-gray-300">Tipo de Recorrência:</label>
                                    <select id="taskRecurrenceType" class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm py-2 px-3 focus:ring-indigo-500 focus:border-indigo-500 text-white">
                                        <option value="specific_days_of_week" class="bg-gray-700">Dias específicos da semana</option>
                                        <option value="every_x_days" class="bg-gray-700">A cada X dias</option>
                                    </select>
                                </div>
                                <div id="taskRecurrenceDaysOfWeekContainer">
                                    <label class="block text-sm font-medium text-gray-300">Repetir nos dias:</label>
                                    <div id="taskRecurrenceDaysOfWeek" class="mt-1 grid grid-cols-2 xs:grid-cols-3 sm:grid-cols-4 gap-2 day-of-week-checkbox-group">
                                        <!-- Checkboxes will be inserted here by JS -->
                                    </div>
                                </div>
                                <div id="taskRecurrenceIntervalContainer" class="hidden">
                                    <label for="taskRecurrenceInterval" class="block text-sm font-medium text-gray-300">Intervalo (dias) <span class="text-red-400">*</span></label>
                                    <input type="number" id="taskRecurrenceInterval" min="1" class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm py-2 px-3 focus:ring-indigo-500 focus:border-indigo-500 text-white" placeholder="Ex: 2 (dia sim, dia não)">
                                </div>
                            </div>
                            
                            <div id="taskNonRecurringDate"> 
                                <div>
                                    <label for="taskDueDate" class="block text-sm font-medium text-gray-300">Data <span class="text-red-400">*</span></label>
                                    <input type="date" id="taskDueDate" required class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm py-2 px-3 focus:ring-indigo-500 focus:border-indigo-500 text-white">
                                </div>
                            </div>

                            <div>
                                <label for="taskStartTime" class="block text-sm font-medium text-gray-300">Hora Início <span class="text-red-400">*</span></label>
                                <input type="time" id="taskStartTime" required class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm py-2 px-3 focus:ring-indigo-500 focus:border-indigo-500 text-white">
                            </div>
                             <button type="button" id="suggestTimeButton" class="w-full bg-sky-600 hover:bg-sky-700 text-white font-medium py-2 px-4 rounded-lg shadow-sm transition duration-150 text-sm">
                                <i class="fas fa-magic mr-2"></i>Sugerir Próximo Horário
                            </button>
                            <div>
                                <label for="taskDescription" class="block text-sm font-medium text-gray-300">Descrição</label>
                                <textarea id="taskDescription" rows="3" class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm py-2 px-3 focus:ring-indigo-500 focus:border-indigo-500 text-white"></textarea>
                            </div>
                            <div class="pt-2">
                                <button type="submit" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2.5 px-4 rounded-lg shadow-md transition duration-150 ease-in-out">
                                    <i class="fas fa-plus-circle mr-2"></i>Adicionar Tarefa
                                </button>
                            </div>
                        </form>
                    </div>

                    <div class="bg-gray-800 p-4 sm:p-6 rounded-xl shadow-lg">
                        <h2 class="text-xl font-semibold text-indigo-400 mb-4">Controles e Filtros</h2>
                         <div class="space-y-3">
                            <div>
                                <label for="filterClient" class="block text-sm font-medium text-gray-300">Filtrar por Cliente:</label>
                                <input type="text" id="filterClient" placeholder="Nome do cliente" class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm py-2 px-3 focus:ring-indigo-500 focus:border-indigo-500 text-white">
                            </div>
                             <div>
                                <label for="filterStatus" class="block text-sm font-medium text-gray-300">Filtrar por Status:</label>
                                <select id="filterStatus" class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm py-2 px-3 focus:ring-indigo-500 focus:border-indigo-500 text-white">
                                    <option value="all" class="bg-gray-700">Todos</option>
                                    <option value="pending" class="bg-gray-700">Pendente</option>
                                    <option value="in-progress" class="bg-gray-700">Em Andamento</option>
                                    <option value="paused" class="bg-gray-700">Pausada</option>
                                    <option value="completed" class="bg-gray-700">Concluída</option>
                                    <option value="overdue" class="bg-gray-700">Atrasada</option>
                                </select>
                            </div>
                             <button id="applyFiltersButton" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-lg shadow-sm transition duration-150">Aplicar Filtros</button>
                             <button id="clearFiltersButton" class="w-full bg-gray-600 hover:bg-gray-500 text-white font-medium py-2 px-4 rounded-lg shadow-sm transition duration-150 mt-2">Limpar Filtros</button>
                         </div>
                    </div>
                    <div class="bg-gray-800 p-4 sm:p-6 rounded-xl shadow-lg">
                        <h2 class="text-xl font-semibold text-indigo-400 mb-4">Configurações</h2>
                        <button id="openWorkHoursModalButton" class="w-full bg-teal-600 hover:bg-teal-700 text-white font-medium py-2 px-4 rounded-lg shadow-sm transition duration-150 mb-3">
                            <i class="fas fa-clock mr-2"></i>Configurar Expediente
                        </button>
                        <button id="clearCompletedTasksButton" class="w-full bg-orange-600 hover:bg-orange-700 text-white font-medium py-2 px-4 rounded-lg shadow-sm transition duration-150">
                            <i class="fas fa-broom mr-2"></i>Limpar Tarefas Concluídas (Histórico)
                        </button>
                         <p id="userIdDisplay" class="text-xs text-gray-500 mt-4 break-all" title="Seu ID de Usuário"></p>
                    </div>

                </div>

                <!-- Coluna de Tarefas / Calendário -->
                <div class="lg:col-span-2 bg-gray-800 p-3 sm:p-4 md:p-6 rounded-xl shadow-lg">
                    <div class="flex flex-col sm:flex-row justify-between items-center mb-4">
                        <h2 class="text-lg sm:text-xl font-semibold text-indigo-400 mb-2 sm:mb-0">
                            Minhas Tarefas <span id="taskListDateHeader" class="text-sm sm:text-base text-gray-400 font-normal"></span>
                        </h2>
                        <div class="flex space-x-2">
                            <button id="viewToggleList" class="view-toggle-button bg-indigo-600 text-white px-3 py-1.5 rounded-md text-sm" title="Visualizar como Lista"><i class="fas fa-list"></i></button>
                            <button id="viewToggleCalendar" class="view-toggle-button bg-gray-600 hover:bg-gray-500 text-white px-3 py-1.5 rounded-md text-sm" title="Visualizar como Calendário"><i class="fas fa-calendar-alt"></i></button>
                        </div>
                    </div>
                    
                    <!-- Visualização em Lista -->
                    <div id="taskListContainer" class="space-y-3 sm:space-y-4 h-[calc(100vh-320px)] sm:h-[calc(100vh-280px)]  overflow-y-auto pr-1">
                        <!-- Tarefas ativas e instâncias recorrentes de hoje serão inseridas aqui -->
                        <p class="text-gray-400 text-center py-4">Nenhuma tarefa para exibir.</p> 
                    </div>

                     <!-- Seção de Tarefas Concluídas (Colapsável) -->
                    <div id="completedTasksSection" class="mt-6 sm:mt-8">
                        <button id="toggleCompletedTasksButton" class="w-full text-left text-md sm:text-lg font-semibold text-indigo-300 hover:text-indigo-200 p-2 sm:p-3 bg-gray-700 hover:bg-gray-600 rounded-lg transition-colors flex justify-between items-center">
                            <span>Tarefas Concluídas <span id="completedTasksDateHeader" class="text-sm sm:text-base text-gray-400 font-normal"></span></span>
                            <i id="completedTasksCaret" class="fas fa-chevron-down transition-transform"></i>
                        </button>
                        <div id="completedTasksListContainer" class="hidden mt-2 space-y-3 p-3 bg-gray-700/50 rounded-b-lg completed-tasks-container">
                            <!-- Tarefas concluídas serão inseridas aqui -->
                            <p class="text-gray-400 text-center py-2">Nenhuma tarefa concluída para exibir.</p>
                        </div>
                    </div>


                    <!-- Visualização em Calendário -->
                    <div id="calendarContainer" class="hidden h-[calc(100vh-250px)] sm:h-[calc(100vh-220px)]">
                        <!-- FullCalendar será inserido aqui -->
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Modal Editar Tarefa -->
    <div id="editTaskModal" class="fixed inset-0 modal-overlay flex items-center justify-center z-[900] hidden p-4">
        <div class="modal-content p-4 sm:p-6 rounded-xl shadow-2xl w-full max-w-md sm:max-w-lg">
            <div class="flex justify-between items-center mb-4 sm:mb-6">
                <h3 class="text-xl sm:text-2xl font-bold text-indigo-400">Editar Tarefa</h3>
                <button id="closeEditTaskModalButton" class="text-gray-400 hover:text-gray-200 text-2xl p-1 leading-none">&times;</button>
            </div>
            <form id="editTaskForm" class="space-y-3 sm:space-y-4">
                <input type="hidden" id="editTaskId">
                <input type="hidden" id="editTaskInstanceDate"> 
                <div>
                    <label for="editTaskTitle" class="block text-sm font-medium text-gray-300">Título <span class="text-red-400">*</span></label>
                    <input type="text" id="editTaskTitle" required class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm py-2 px-3 focus:ring-indigo-500 focus:border-indigo-500 text-white">
                </div>
                <div>
                    <label for="editTaskClient" class="block text-sm font-medium text-gray-300">Cliente</label>
                    <input type="text" id="editTaskClient" class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm py-2 px-3 focus:ring-indigo-500 focus:border-indigo-500 text-white">
                </div>
                <div>
                    <label for="editTaskType" class="block text-sm font-medium text-gray-300">Tipo</label>
                    <input type="text" id="editTaskType" class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm py-2 px-3 focus:ring-indigo-500 focus:border-indigo-500 text-white">
                </div>
                <div>
                    <label for="editTaskPriority" class="block text-sm font-medium text-gray-300">Prioridade</label>
                    <select id="editTaskPriority" class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm py-2 px-3 focus:ring-indigo-500 focus:border-indigo-500 text-white">
                        <option value="low" class="bg-gray-700">Baixa</option>
                        <option value="medium" class="bg-gray-700">Média</option>
                        <option value="high" class="bg-gray-700">Alta</option>
                        <option value="urgent" class="bg-gray-700">Urgente</option>
                    </select>
                </div>
                <div>
                    <label for="editTaskEstimatedTime" class="block text-sm font-medium text-gray-300">Tempo Estimado (min) <span class="text-red-400">*</span></label>
                    <input type="number" id="editTaskEstimatedTime" min="1" required class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm py-2 px-3 focus:ring-indigo-500 focus:border-indigo-500 text-white">
                </div>
                
                <!-- Edit Recurrence Options -->
                 <div class="flex items-center">
                    <input type="checkbox" id="editTaskIsRecurring" class="h-4 w-4 text-indigo-600 border-gray-500 rounded focus:ring-indigo-500">
                    <label for="editTaskIsRecurring" class="ml-2 block text-sm text-gray-300">Tarefa Recorrente</label>
                </div>
                <div id="editRecurrenceDetails" class="hidden space-y-3 pl-6 border-l-2 border-gray-700 ml-2">
                     <div>
                        <label for="editTaskRecurrenceStartDate" class="block text-sm font-medium text-gray-300">Data de Início da Recorrência <span class="text-red-400">*</span></label>
                        <input type="date" id="editTaskRecurrenceStartDate" class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm py-2 px-3 focus:ring-indigo-500 focus:border-indigo-500 text-white">
                    </div>
                     <div>
                        <label class="block text-sm font-medium text-gray-300">Tipo de Recorrência:</label>
                        <select id="editTaskRecurrenceType" class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm py-2 px-3 focus:ring-indigo-500 focus:border-indigo-500 text-white">
                            <option value="specific_days_of_week" class="bg-gray-700">Dias específicos da semana</option>
                            <option value="every_x_days" class="bg-gray-700">A cada X dias</option>
                        </select>
                    </div>
                    <div id="editTaskRecurrenceDaysOfWeekContainer">
                        <label class="block text-sm font-medium text-gray-300">Repetir nos dias:</label>
                        <div id="editTaskRecurrenceDaysOfWeek" class="mt-1 grid grid-cols-2 xs:grid-cols-3 sm:grid-cols-4 gap-2 day-of-week-checkbox-group">
                            <!-- Checkboxes will be inserted here by JS -->
                        </div>
                    </div>
                     <div id="editTaskRecurrenceIntervalContainer" class="hidden">
                        <label for="editTaskRecurrenceInterval" class="block text-sm font-medium text-gray-300">Intervalo (dias) <span class="text-red-400">*</span></label>
                        <input type="number" id="editTaskRecurrenceInterval" min="1" class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm py-2 px-3 focus:ring-indigo-500 focus:border-indigo-500 text-white">
                    </div>
                </div>

                <div id="editTaskNonRecurringDate"> 
                    <div>
                        <label for="editTaskDueDate" class="block text-sm font-medium text-gray-300">Data <span class="text-red-400">*</span></label>
                        <input type="date" id="editTaskDueDate" required class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm py-2 px-3 focus:ring-indigo-500 focus:border-indigo-500 text-white">
                    </div>
                </div>
                <div>
                    <label for="editTaskStartTime" class="block text-sm font-medium text-gray-300">Hora Início <span class="text-red-400">*</span></label>
                    <input type="time" id="editTaskStartTime" required class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm py-2 px-3 focus:ring-indigo-500 focus:border-indigo-500 text-white">
                </div>
                 <button type="button" id="editSuggestTimeButton" class="w-full bg-sky-600 hover:bg-sky-700 text-white font-medium py-2 px-4 rounded-lg shadow-sm transition duration-150 text-sm">
                    <i class="fas fa-magic mr-2"></i>Sugerir Próximo Horário
                </button>
                 <div>
                    <label for="editTaskStatus" class="block text-sm font-medium text-gray-300">Status (Padrão para Novas Ocorrências)</label>
                    <select id="editTaskStatus" class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm py-2 px-3 focus:ring-indigo-500 focus:border-indigo-500 text-white">
                        <option value="pending" class="bg-gray-700">Pendente</option>
                        <option value="in-progress" class="bg-gray-700">Em Andamento</option>
                        <option value="paused" class="bg-gray-700">Pausada</option>
                        <!-- 'Completed' and 'Overdue' are instance-specific for recurring tasks -->
                    </select>
                </div>
                <div>
                    <label for="editTaskDescription" class="block text-sm font-medium text-gray-300">Descrição</label>
                    <textarea id="editTaskDescription" rows="3" class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm py-2 px-3 focus:ring-indigo-500 focus:border-indigo-500 text-white"></textarea>
                </div>
                 <div id="editTaskDailyRescheduleOptions" class="hidden space-y-2 pt-2"> 
                    <button type="button" id="createOneOffInstanceButton" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-medium py-2 px-4 rounded-lg shadow-sm text-sm">
                        <i class="fas fa-calendar-day mr-2"></i>Criar Instância Única para Hoje (Outro Horário)
                    </button>
                </div>
                <div class="flex flex-col sm:flex-row justify-end space-y-2 sm:space-y-0 sm:space-x-3 pt-3">
                    <button type="button" id="triggerDeleteTaskButton" class="w-full sm:w-auto bg-red-600 hover:bg-red-700 text-white font-medium py-2 px-4 rounded-lg shadow-sm">Excluir</button>
                    <button type="submit" class="w-full sm:w-auto bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-2 px-4 rounded-lg shadow-sm">Salvar Alterações</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Modal Opções de Exclusão de Tarefa Recorrente -->
    <div id="deleteRecurrenceOptionsModal" class="fixed inset-0 modal-overlay flex items-center justify-center z-[960] hidden p-4">
        <div class="modal-content p-6 rounded-xl shadow-2xl w-full max-w-md">
            <h3 class="text-xl font-semibold text-indigo-400 mb-4">Opções de Exclusão</h3>
            <p class="text-gray-300 mb-6">Esta é uma tarefa recorrente. Como você gostaria de excluí-la?</p>
            <div class="space-y-3">
                <button id="deleteThisInstanceButton" class="w-full bg-yellow-600 hover:bg-yellow-700 text-white font-medium py-2 px-4 rounded-lg shadow-sm">
                    Excluir Somente Esta Ocorrência
                </button>
                <button id="deleteFutureInstancesButton" class="w-full bg-orange-600 hover:bg-orange-700 text-white font-medium py-2 px-4 rounded-lg shadow-sm">
                    Excluir Esta e Futuras Ocorrências
                </button>
                <button id="deleteAllInstancesButton" class="w-full bg-red-700 hover:bg-red-800 text-white font-medium py-2 px-4 rounded-lg shadow-sm">
                    Excluir Todas as Ocorrências (Série Completa)
                </button>
            </div>
            <div class="mt-6 text-right">
                <button id="cancelDeleteRecurrenceButton" class="bg-gray-600 hover:bg-gray-500 text-white font-medium py-2 px-4 rounded-lg shadow-sm">
                    Cancelar
                </button>
            </div>
        </div>
    </div>


    <!-- Modal Configurar Expediente -->
    <div id="workHoursModal" class="fixed inset-0 modal-overlay flex items-center justify-center z-[900] hidden p-4">
        <div class="modal-content p-6 rounded-xl shadow-2xl w-full max-w-2xl">
            <div class="flex justify-between items-center mb-6">
                <h3 class="text-2xl font-bold text-indigo-400">Configurar Expediente</h3>
                <button id="closeWorkHoursModalButton" class="text-gray-400 hover:text-gray-200 text-2xl p-1 leading-none">&times;</button>
            </div>
            <form id="workHoursForm" class="space-y-3">
                <p class="text-sm text-gray-400 mb-3">Defina seus horários de trabalho. Deixe em branco se não houver expediente no período.</p>
                <div id="workHoursInputsContainer" class="space-y-4 max-h-[calc(90vh-180px)] overflow-y-auto pr-2">
                    <!-- Inputs de expediente serão gerados aqui -->
                </div>
                <div class="flex justify-end pt-4">
                    <button type="submit" class="bg-teal-600 hover:bg-teal-700 text-white font-medium py-2.5 px-5 rounded-lg shadow-sm">Salvar Expediente</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Modal de Confirmação Genérico -->
    <div id="confirmationModal" class="fixed inset-0 modal-overlay flex items-center justify-center z-[950] hidden p-4">
        <div class="modal-content p-6 rounded-xl shadow-2xl w-full max-w-sm">
            <h3 id="confirmationModalTitle" class="text-xl font-semibold text-indigo-400 mb-4">Confirmar Ação</h3>
            <p id="confirmationModalMessage" class="text-gray-300 mb-6">Você tem certeza?</p>
            <div class="flex justify-end space-x-3">
                <button id="confirmationModalCancelButton" class="bg-gray-600 hover:bg-gray-500 text-white font-medium py-2 px-4 rounded-lg shadow-sm">Cancelar</button>
                <button id="confirmationModalConfirmButton" class="bg-red-600 hover:bg-red-700 text-white font-medium py-2 px-4 rounded-lg shadow-sm">Confirmar</button>
            </div>
        </div>
    </div>

     <!-- Pop-up de Ações Rápidas do Calendário -->
    <div id="calendarEventQuickActions" class="hidden">
        <div id="quickActionTaskTitle" class="quick-action-title"></div>
        <button id="quickActionStartEstimated"><i class="fas fa-play mr-2"></i>Iniciar (Estim.)</button>
        <button id="quickActionPauseEstimated" class="hidden"><i class="fas fa-pause mr-2"></i>Pausar (Estim.)</button>
        <button id="quickActionResumeEstimated" class="hidden"><i class="fas fa-play-circle mr-2"></i>Retomar (Estim.)</button>

        <button id="quickActionStartTracking"><i class="fas fa-stopwatch mr-2"></i>Iniciar Cronômetro</button>
        <button id="quickActionStopTracking" class="hidden"><i class="fas fa-stop-circle mr-2"></i>Parar Cronômetro</button>
        
        <button id="quickActionCompleteTask"><i class="fas fa-check-circle mr-2"></i>Concluir Tarefa</button>
        <button id="quickActionEditTask"><i class="fas fa-edit mr-2"></i>Editar Completo</button>
        <button id="quickActionDeleteTask" class="!text-red-400 hover:!bg-red-700"><i class="fas fa-trash-alt mr-2"></i>Excluir</button>
    </div>


    <!-- Firebase SDKs -->
    <script type="module">
        // Importações do Firebase
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { 
            getAuth, 
            createUserWithEmailAndPassword, 
            signInWithEmailAndPassword, 
            signOut, 
            onAuthStateChanged 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            setDoc, 
            addDoc, 
            getDoc, 
            updateDoc, 
            deleteDoc, 
            collection, 
            query, 
            where, 
            onSnapshot,
            serverTimestamp,
            Timestamp, 
            orderBy,
            writeBatch,
            enableNetwork, 
            disableNetwork,
            runTransaction 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Configuração do Firebase ---
        const firebaseConfigFromGlobal = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const appIdFromGlobal = typeof __app_id !== 'undefined' ? __app_id : 'default-agenda-pro-app';

        const fallbackFirebaseConfig = { 
            apiKey: "AIzaSyDU6b-kVcnyEtYnzdjF_vCk1zcXyYTkPww",
            authDomain: "agendapriscila-39204.firebaseapp.com",
            projectId: "agendapriscila-39204",
            storageBucket: "agendapriscila-39204.firebasestorage.app",
            messagingSenderId: "888563344778",
            appId: "1:888563344778:web:ee8608deb139c94f49d473",
            measurementId: "G-XB6G2H4FYS"
        };
        
        const finalFirebaseConfig = firebaseConfigFromGlobal || fallbackFirebaseConfig;
        
        let app;
        let auth;
        let db;
        let currentUserId = null;
        let tasksCollectionRef = null;
        let workHoursConfigRef = null;
        let unsubscribeTasks = null;
        let unsubscribeWorkHours = null;
        let userWorkHours = {}; 
        let calendar = null;
        let currentView = 'list'; 
        let allUserTasks = []; 
        let currentFilters = { client: '', status: 'all' };
        let countdownInterval = null; 
        let activeTaskTimerInterval = null; 
        let currentConfirmAction = null; 
        let taskToDeleteId = null; 
        let instanceDateToDelete = null; 
        let selectedDateForList = new Date().toISOString().split('T')[0]; 


        const daysOfWeekMap = [
            { id: 0, name: 'Domingo' }, { id: 1, name: 'Segunda' }, { id: 2, name: 'Terça' },
            { id: 3, name: 'Quarta' }, { id: 4, name: 'Quinta' }, { id: 5, name: 'Sexta' },
            { id: 6, name: 'Sábado' }
        ];

        try {
            app = initializeApp(finalFirebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            console.log("Firebase inicializado com sucesso. App ID:", appIdFromGlobal);
        } catch (error) {
            console.error("Erro Crítico ao inicializar Firebase:", error);
        }

        // --- Seletores de Elementos da UI ---
        const loadingOverlay = document.getElementById('loadingOverlay');
        const toastContainer = document.getElementById('toastContainer');
        const authSection = document.getElementById('authSection');
        const emailInput = document.getElementById('email');
        const passwordInput = document.getElementById('password');
        const authButton = document.getElementById('authButton');
        // const switchToRegisterButton = document.getElementById('switchToRegisterButton'); // Removido
        const authError = document.getElementById('authError');
        const agendaSection = document.getElementById('agendaSection');
        const userEmailDisplay = document.getElementById('userEmailDisplay');
        const userIdDisplay = document.getElementById('userIdDisplay');
        const logoutButton = document.getElementById('logoutButton');
        
        const addTaskForm = document.getElementById('addTaskForm');
        const taskTitleInput = document.getElementById('taskTitle');
        const taskClientInput = document.getElementById('taskClient');
        const taskTypeInput = document.getElementById('taskType');
        const taskPriorityInput = document.getElementById('taskPriority');
        const taskEstimatedTimeInput = document.getElementById('taskEstimatedTime');
        
        const taskIsRecurringCheckbox = document.getElementById('taskIsRecurring');
        const recurrenceDetailsDiv = document.getElementById('recurrenceDetails');
        const taskRecurrenceStartDateInput = document.getElementById('taskRecurrenceStartDate');
        const taskRecurrenceTypeSelect = document.getElementById('taskRecurrenceType');
        const taskRecurrenceDaysOfWeekContainer = document.getElementById('taskRecurrenceDaysOfWeekContainer');
        const taskRecurrenceDaysOfWeekDiv = document.getElementById('taskRecurrenceDaysOfWeek');
        const taskRecurrenceIntervalContainer = document.getElementById('taskRecurrenceIntervalContainer');
        const taskRecurrenceIntervalInput = document.getElementById('taskRecurrenceInterval');
        const taskNonRecurringDateDiv = document.getElementById('taskNonRecurringDate');
        const taskDueDateInput = document.getElementById('taskDueDate');
        
        const taskStartTimeInput = document.getElementById('taskStartTime');
        const taskDescriptionInput = document.getElementById('taskDescription');
        const suggestTimeButton = document.getElementById('suggestTimeButton');

        const taskListContainer = document.getElementById('taskListContainer');
        const taskListDateHeader = document.getElementById('taskListDateHeader'); 
        const calendarContainer = document.getElementById('calendarContainer');
        const viewToggleListButton = document.getElementById('viewToggleList');
        const viewToggleCalendarButton = document.getElementById('viewToggleCalendar');

        const completedTasksSection = document.getElementById('completedTasksSection');
        const toggleCompletedTasksButton = document.getElementById('toggleCompletedTasksButton');
        const completedTasksListContainer = document.getElementById('completedTasksListContainer');
        const completedTasksDateHeader = document.getElementById('completedTasksDateHeader'); 
        const completedTasksCaret = document.getElementById('completedTasksCaret');

        const editTaskModal = document.getElementById('editTaskModal');
        const closeEditTaskModalButton = document.getElementById('closeEditTaskModalButton');
        const editTaskForm = document.getElementById('editTaskForm');
        const editTaskIdInput = document.getElementById('editTaskId');
        const editTaskInstanceDateInput = document.getElementById('editTaskInstanceDate');
        const editTaskTitleInput = document.getElementById('editTaskTitle');
        const editTaskClientInput = document.getElementById('editTaskClient');
        const editTaskTypeInput = document.getElementById('editTaskType');
        const editTaskPriorityInput = document.getElementById('editTaskPriority');
        const editTaskEstimatedTimeInput = document.getElementById('editTaskEstimatedTime');

        const editTaskIsRecurringCheckbox = document.getElementById('editTaskIsRecurring');
        const editRecurrenceDetailsDiv = document.getElementById('editRecurrenceDetails');
        const editTaskRecurrenceStartDateInput = document.getElementById('editTaskRecurrenceStartDate');
        const editTaskRecurrenceTypeSelect = document.getElementById('editTaskRecurrenceType');
        const editTaskRecurrenceDaysOfWeekContainer = document.getElementById('editTaskRecurrenceDaysOfWeekContainer');
        const editTaskRecurrenceDaysOfWeekDiv = document.getElementById('editTaskRecurrenceDaysOfWeek');
        const editTaskRecurrenceIntervalContainer = document.getElementById('editTaskRecurrenceIntervalContainer');
        const editTaskRecurrenceIntervalInput = document.getElementById('editTaskRecurrenceInterval');
        const editTaskNonRecurringDateDiv = document.getElementById('editTaskNonRecurringDate');
        const editTaskDueDateInput = document.getElementById('editTaskDueDate');

        const editTaskStartTimeInput = document.getElementById('editTaskStartTime');
        const editSuggestTimeButton = document.getElementById('editSuggestTimeButton');
        const editTaskStatusInput = document.getElementById('editTaskStatus');
        const editTaskDescriptionInput = document.getElementById('editTaskDescription');
        const triggerDeleteTaskButton = document.getElementById('triggerDeleteTaskButton');
        const editTaskRecurrenceOptionsDiv = document.getElementById('editTaskDailyRescheduleOptions'); 
        const createOneOffInstanceButton = document.getElementById('createOneOffInstanceButton'); 
        
        const openWorkHoursModalButton = document.getElementById('openWorkHoursModalButton');
        const workHoursModal = document.getElementById('workHoursModal');
        const closeWorkHoursModalButton = document.getElementById('closeWorkHoursModalButton');
        const workHoursForm = document.getElementById('workHoursForm');
        const workHoursInputsContainer = document.getElementById('workHoursInputsContainer');

        const filterClientInput = document.getElementById('filterClient');
        const filterStatusSelect = document.getElementById('filterStatus');
        const applyFiltersButton = document.getElementById('applyFiltersButton');
        const clearFiltersButton = document.getElementById('clearFiltersButton');
        const clearCompletedTasksButton = document.getElementById('clearCompletedTasksButton');

        const confirmationModal = document.getElementById('confirmationModal');
        const confirmationModalTitle = document.getElementById('confirmationModalTitle');
        const confirmationModalMessage = document.getElementById('confirmationModalMessage');
        const confirmationModalCancelButton = document.getElementById('confirmationModalCancelButton');
        const confirmationModalConfirmButton = document.getElementById('confirmationModalConfirmButton');

        const deleteRecurrenceOptionsModal = document.getElementById('deleteRecurrenceOptionsModal');
        const deleteThisInstanceButton = document.getElementById('deleteThisInstanceButton');
        const deleteFutureInstancesButton = document.getElementById('deleteFutureInstancesButton');
        const deleteAllInstancesButton = document.getElementById('deleteAllInstancesButton');
        const cancelDeleteRecurrenceButton = document.getElementById('cancelDeleteRecurrenceButton');

        let calendarEventQuickActionsPopup;
        let quickActionTaskTitle;
        let quickActionStartEstimatedButton;
        let quickActionPauseEstimatedButton; 
        let quickActionResumeEstimatedButton; 
        let quickActionStartTrackingButton;
        let quickActionStopTrackingButton; 
        let quickActionCompleteTaskButton; 
        let quickActionEditTaskButton;
        let quickActionDeleteTaskButton;


        document.addEventListener('DOMContentLoaded', () => { 
            calendarEventQuickActionsPopup = document.getElementById('calendarEventQuickActions');
            quickActionTaskTitle = document.getElementById('quickActionTaskTitle');
            quickActionStartEstimatedButton = document.getElementById('quickActionStartEstimated');
            quickActionPauseEstimatedButton = document.getElementById('quickActionPauseEstimated');
            quickActionResumeEstimatedButton = document.getElementById('quickActionResumeEstimated');
            quickActionStartTrackingButton = document.getElementById('quickActionStartTracking');
            quickActionStopTrackingButton = document.getElementById('quickActionStopTracking');
            quickActionCompleteTaskButton = document.getElementById('quickActionCompleteTask');
            quickActionEditTaskButton = document.getElementById('quickActionEditTask');
            quickActionDeleteTaskButton = document.getElementById('quickActionDeleteTask');

            populateDayOfWeekCheckboxes('taskRecurrenceDaysOfWeek', 'task'); 
            populateDayOfWeekCheckboxes('editTaskRecurrenceDaysOfWeek', 'editTask');
            showLoadingIndicator(); 
            setupEventListeners(); 
        });


        function populateDayOfWeekCheckboxes(containerElementId, prefix = "task") {
            const container = document.getElementById(containerElementId);
            if (!container) { console.error(`Contêiner de checkbox "${containerElementId}" não encontrado.`); return; }
            container.innerHTML = ''; 
            daysOfWeekMap.forEach(day => {
                const div = document.createElement('div');
                const checkboxId = `${prefix}RecurrenceDay_${day.id}`;
                div.innerHTML = `
                    <input type="checkbox" id="${checkboxId}" name="${prefix}RecurrenceDay" value="${day.id}" class="h-4 w-4 text-indigo-600 border-gray-500 rounded focus:ring-indigo-500">
                    <label for="${checkboxId}" class="ml-1 text-sm text-gray-300">${day.name.substring(0,3)}</label>
                `;
                container.appendChild(div);
            });
        }
        

        // --- Funções Utilitárias ---
        function showLoadingIndicator(show = true) { if (loadingOverlay) { loadingOverlay.classList.toggle('opacity-0', !show); loadingOverlay.classList.toggle('pointer-events-none', !show); }}
        function showToast(message, type = 'success', duration = 4000) { /* ... (sem alterações) ... */ 
            const toastElement = document.createElement('div');
            toastElement.className = `toast p-4 rounded-lg shadow-xl mb-3 flex items-center space-x-3 text-white text-sm font-medium max-w-sm`;
            let iconHtml = '';
            let bgColor = '';

            switch (type) {
                case 'success': bgColor = 'bg-green-600'; iconHtml = '<i class="fas fa-check-circle fa-lg"></i>'; break;
                case 'error': bgColor = 'bg-red-600'; iconHtml = '<i class="fas fa-times-circle fa-lg"></i>'; break;
                case 'info': bgColor = 'bg-blue-600'; iconHtml = '<i class="fas fa-info-circle fa-lg"></i>'; break;
                default: bgColor = 'bg-gray-700'; iconHtml = '<i class="fas fa-bell fa-lg"></i>';
            }
            toastElement.classList.add(bgColor);
            toastElement.innerHTML = `${iconHtml} <span class="flex-1">${message}</span>`;
            toastContainer.appendChild(toastElement);
            
            toastElement.offsetHeight; 

            setTimeout(() => {
                toastElement.style.animation = 'fadeOutToast 0.4s ease-in forwards';
                setTimeout(() => toastElement.remove(), 400);
            }, duration - 400);
        }
        function openConfirmationModal(title, message, onConfirm) { 
             if (!confirmationModalTitle || !confirmationModalMessage || !confirmationModal) {
                console.error("Elementos do modal de confirmação não encontrados no DOM.");
                if (confirm(`${title}\n${message}`)) { // Fallback
                    if(typeof onConfirm === 'function') onConfirm();
                }
                return;
            }
            confirmationModalTitle.textContent = title;
            confirmationModalMessage.textContent = message;
            currentConfirmAction = onConfirm; 
            confirmationModal.classList.remove('hidden');
        }
        confirmationModalCancelButton.addEventListener('click', () => { confirmationModal.classList.add('hidden'); currentConfirmAction = null; });
        confirmationModalConfirmButton.addEventListener('click', () => { if (typeof currentConfirmAction === 'function') currentConfirmAction(); confirmationModal.classList.add('hidden'); currentConfirmAction = null; });

        function formatSecondsToHHMMSS(totalSeconds) {
            if (typeof totalSeconds !== 'number' || totalSeconds < 0) return '00:00:00';
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        // --- Lógica de Autenticação ---
        // REMOVIDO: let isRegistering = false;
        // REMOVIDO: switchToRegisterButton.addEventListener('click', ...);
        authButton.addEventListener('click', async () => { 
            const email = emailInput.value.trim(); const password = passwordInput.value.trim();
            authError.classList.add('hidden'); authError.textContent = '';
            if (!email || !password) { authError.textContent = 'Por favor, preencha email e senha.'; authError.classList.remove('hidden'); return; }
            if (password.length < 6) { authError.textContent = 'A senha deve ter pelo menos 6 caracteres.'; authError.classList.remove('hidden'); return; }
            showLoadingIndicator();
            try {
                // Apenas tenta fazer login, já que o registro foi removido
                await signInWithEmailAndPassword(auth, email, password);
                showToast('Login bem-sucedido!', 'success');
            } catch (error) {
                console.error("Erro de autenticação:", error.code, error.message);
                const friendlyMessage = mapAuthErrorToMessage(error.code);
                authError.textContent = friendlyMessage; authError.classList.remove('hidden');
                showToast(friendlyMessage, 'error', 5000);
            } finally { if (!auth.currentUser) showLoadingIndicator(false); } 
        });
        function mapAuthErrorToMessage(errorCode) {
             switch (errorCode) {
                case 'auth/invalid-email': return 'Formato de email inválido.';
                case 'auth/user-disabled': return 'Este usuário foi desabilitado.';
                case 'auth/user-not-found': return 'Usuário não encontrado.';
                case 'auth/wrong-password': return 'Senha incorreta.';
                // REMOVIDO: case 'auth/email-already-in-use': return 'Este email já está em uso.';
                // REMOVIDO: case 'auth/weak-password': return 'Senha muito fraca. Use pelo menos 6 caracteres.';
                case 'auth/operation-not-allowed': return 'Operação não permitida. Verifique se o login por Email/Senha está HABILITADO no seu Console Firebase (Authentication -> Sign-in method).'; 
                case 'auth/network-request-failed': return 'Erro de rede. Verifique sua conexão.';
                default: return 'Ocorreu um erro na autenticação.';
            }
        }
        logoutButton.addEventListener('click', async () => { /* ... (sem alterações) ... */ 
            showLoadingIndicator();
            try { await signOut(auth); showToast('Logout realizado com sucesso.', 'info');
            } catch (error) { console.error("Erro ao fazer logout:", error); showToast('Erro ao fazer logout.', 'error');
            } finally { showLoadingIndicator(false); }
        });
        onAuthStateChanged(auth, (user) => { /* ... (sem alterações) ... */ 
            showLoadingIndicator(); 
            if (user) {
                currentUserId = user.uid;
                userEmailDisplay.textContent = user.email; userEmailDisplay.title = user.email; 
                userIdDisplay.textContent = `ID Usuário: ${user.uid}`; userIdDisplay.title = user.uid;
                authSection.classList.add('hidden'); agendaSection.classList.remove('hidden');
                initializeUserSpecificRefs(); 
                if(db) { 
                    enableNetwork(db).then(() => { 
                        loadTasks(); loadWorkHours(); startGlobalCountdownTimer();
                    }).catch(err => { console.error("Erro Firestore network:", err); showToast("Erro de conexão com DB.", "error", 6000); });
                } else { showToast("DB não inicializado.", "error", 6000); }
                initializeCalendar(); 
            } else {
                currentUserId = null;
                authSection.classList.remove('hidden'); agendaSection.classList.add('hidden');
                userEmailDisplay.textContent = ''; userEmailDisplay.title = ''; userIdDisplay.textContent = ''; userIdDisplay.title = '';
                allUserTasks = []; userWorkHours = {}; renderTaskList([]); 
                if (calendar) calendar.removeAllEvents(); 
                if (unsubscribeTasks) unsubscribeTasks(); if (unsubscribeWorkHours) unsubscribeWorkHours();
                stopGlobalCountdownTimer(); unsubscribeTasks = null; unsubscribeWorkHours = null;
                tasksCollectionRef = null; workHoursConfigRef = null;
                if(db) disableNetwork(db).catch(err => console.warn("Erro disable network:", err)); 
            }
            showLoadingIndicator(false); 
        });
        function initializeUserSpecificRefs() { /* ... (sem alterações) ... */ 
             if (!currentUserId || !db) { console.warn("Refs init sem userId/db."); return; }
            tasksCollectionRef = collection(db, `artifacts/${appIdFromGlobal}/users/${currentUserId}/agendaTasks`);
            workHoursConfigRef = doc(db, `artifacts/${appIdFromGlobal}/users/${currentUserId}/agendaConfig/workHours`);
        }
        
        // --- Lógica de Tarefas (CRUD) ---
        function getTaskEndTime(startTime, estimatedTimeMinutes) { /* ... (sem alterações) ... */ 
            if (!startTime || !estimatedTimeMinutes) return null;
            try {
                const [hours, minutes] = startTime.split(':').map(Number);
                const date = new Date(); date.setHours(hours, minutes, 0, 0);
                date.setMinutes(date.getMinutes() + parseInt(estimatedTimeMinutes));
                return `${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
            } catch (e) { console.error("Erro getTaskEndTime:", e); return null; }
        }
        
        addTaskForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            if (!tasksCollectionRef) { showToast('Erro: DB não conectado.', 'error'); return; }
            
            const title = taskTitleInput.value.trim();
            const estimatedTime = taskEstimatedTimeInput.value ? parseInt(taskEstimatedTimeInput.value) : 0;
            const isRecurring = taskIsRecurringCheckbox.checked;
            const startTime = taskStartTimeInput.value || null;

            if (!title) { showToast("Título é obrigatório.", "error"); return; }
            if (estimatedTime <= 0) { showToast("Tempo estimado > 0.", "error"); return; }
            if (!startTime) { showToast("Hora de início é obrigatória.", "error"); return; }

            let taskData = {
                title: title, client: taskClientInput.value.trim() || null, type: taskTypeInput.value.trim() || null,
                priority: taskPriorityInput.value, estimatedTime: estimatedTime, originalEstimatedTime: estimatedTime,
                startTime: startTime, description: taskDescriptionInput.value.trim() || null, status: 'pending', 
                userId: currentUserId, createdAt: serverTimestamp(), updatedAt: serverTimestamp(),
                remainingSeconds: estimatedTime * 60, lastStartTime: null, 
                timeTrackedSeconds: 0, isTrackingTime: false, lastTrackingStartTime: null, // Cronômetro
                completedDates: [], skippedDates: [], 
                isRecurring: isRecurring, 
                recurrenceType: null, recurrenceDaysOfWeek: null, recurrenceStartDate: null, recurrenceInterval: null, recurrenceEndDate: null,
            };

            if (isRecurring) {
                taskData.recurrenceType = taskRecurrenceTypeSelect.value;
                const recStartDate = taskRecurrenceStartDateInput.value;
                if (!recStartDate) { showToast("Data de início da recorrência é obrigatória.", "error"); return; }
                taskData.recurrenceStartDate = recStartDate;

                if (taskData.recurrenceType === 'specific_days_of_week') {
                    const selectedDays = Array.from(taskRecurrenceDaysOfWeekDiv.querySelectorAll('input[type="checkbox"]:checked')).map(cb => parseInt(cb.value));
                    if (selectedDays.length === 0) { showToast("Selecione pelo menos um dia para recorrência semanal.", "error"); return; }
                    taskData.recurrenceDaysOfWeek = selectedDays;
                    taskData.recurrenceInterval = null; 
                } else if (taskData.recurrenceType === 'every_x_days') {
                    const interval = parseInt(taskRecurrenceIntervalInput.value);
                    if (!interval || interval <= 0) { showToast("Intervalo de dias deve ser maior que zero.", "error"); return; }
                    taskData.recurrenceInterval = interval;
                    taskData.recurrenceDaysOfWeek = null; 
                }
                taskData.dueDate = null; 
            } else {
                const dueDate = taskDueDateInput.value;
                if (!dueDate) { showToast("Data é obrigatória para tarefas não recorrentes.", "error"); return; }
                taskData.dueDate = dueDate;
            }
            
            showLoadingIndicator();
            const conflicts = await checkConflicts(taskData, allUserTasks);
            if (conflicts.length > 0) {
                const conflictMessages = conflicts.map(c => `'${c.title}' (${c.startTime} em ${c.isRecurring ? `Recorrente (primeira em ${c.recurrenceStartDate || 'N/A'})` : c.dueDate})`).join(', ');
                showToast(`Conflito: ${conflictMessages}. Ajuste.`, 'error', 7000);
                showLoadingIndicator(false); return;
            }

            try {
                await addDoc(tasksCollectionRef, taskData);
                showToast('Tarefa adicionada!', 'success');
                addTaskForm.reset();
                taskDueDateInput.value = ''; taskRecurrenceStartDateInput.value = ''; taskRecurrenceIntervalInput.value = '';
                taskIsRecurringCheckbox.dispatchEvent(new Event('change')); 
                taskRecurrenceTypeSelect.dispatchEvent(new Event('change'));
            } catch (error) {
                console.error("Erro ao adicionar tarefa:", error);
                showToast('Erro ao adicionar tarefa.', 'error', 6000);
            } finally { showLoadingIndicator(false); }
        });

        function toggleRecurrenceFields(checkbox, detailsDiv, nonRecurringDiv, startDateInput, dueDateInput, typeSelect, daysContainer, intervalContainer) {
            if (checkbox.checked) {
                detailsDiv.classList.remove('hidden');
                nonRecurringDiv.classList.add('hidden');
                dueDateInput.required = false;
                startDateInput.required = true;
                if (typeSelect.value === 'specific_days_of_week') {
                    daysContainer.classList.remove('hidden');
                    intervalContainer.classList.add('hidden');
                    if (intervalContainer.querySelector('input')) intervalContainer.querySelector('input').required = false; 
                } else if (typeSelect.value === 'every_x_days') {
                    daysContainer.classList.add('hidden');
                    intervalContainer.classList.remove('hidden');
                    if (intervalContainer.querySelector('input')) intervalContainer.querySelector('input').required = true;
                }
            } else {
                detailsDiv.classList.add('hidden');
                nonRecurringDiv.classList.remove('hidden');
                dueDateInput.required = true;
                startDateInput.required = false;
                daysContainer.classList.add('hidden');
                intervalContainer.classList.add('hidden');
                if (intervalContainer.querySelector('input')) intervalContainer.querySelector('input').required = false;
            }
        }

        taskIsRecurringCheckbox.addEventListener('change', (e) => {
            toggleRecurrenceFields(e.target, recurrenceDetailsDiv, taskNonRecurringDateDiv, taskRecurrenceStartDateInput, taskDueDateInput, taskRecurrenceTypeSelect, taskRecurrenceDaysOfWeekContainer, taskRecurrenceIntervalContainer);
        });
        taskRecurrenceTypeSelect.addEventListener('change', (e) => { 
             toggleRecurrenceFields(taskIsRecurringCheckbox, recurrenceDetailsDiv, taskNonRecurringDateDiv, taskRecurrenceStartDateInput, taskDueDateInput, e.target, taskRecurrenceDaysOfWeekContainer, taskRecurrenceIntervalContainer);
        });

        editTaskIsRecurringCheckbox.addEventListener('change', (e) => {
            toggleRecurrenceFields(e.target, editRecurrenceDetailsDiv, editTaskNonRecurringDateDiv, editTaskRecurrenceStartDateInput, editTaskDueDateInput, editTaskRecurrenceTypeSelect, editTaskRecurrenceDaysOfWeekContainer, editTaskRecurrenceIntervalContainer);
            editTaskRecurrenceOptionsDiv.classList.toggle('hidden', !e.target.checked); 
        });
        editTaskRecurrenceTypeSelect.addEventListener('change', (e) => {
            toggleRecurrenceFields(editTaskIsRecurringCheckbox, editRecurrenceDetailsDiv, editTaskNonRecurringDateDiv, editTaskRecurrenceStartDateInput, editTaskDueDateInput, e.target, editTaskRecurrenceDaysOfWeekContainer, editTaskRecurrenceIntervalContainer);
        });


        function loadTasks() { 
             if (!tasksCollectionRef) { showLoadingIndicator(false); return; }
            if (unsubscribeTasks) unsubscribeTasks(); 
            showLoadingIndicator();
            const q = query(tasksCollectionRef, orderBy("createdAt", "desc")); 
            unsubscribeTasks = onSnapshot(q, (snapshot) => {
                allUserTasks = snapshot.docs.map(doc => ({ 
                    id: doc.id, 
                    ...doc.data(),
                    completedDates: Array.isArray(doc.data().completedDates) ? doc.data().completedDates : [],
                    skippedDates: Array.isArray(doc.data().skippedDates) ? doc.data().skippedDates : [],
                    recurrenceDaysOfWeek: Array.isArray(doc.data().recurrenceDaysOfWeek) ? doc.data().recurrenceDaysOfWeek : null,
                }));
                applyFiltersAndRenderTasks(); 
                showLoadingIndicator(false);
            }, (error) => {
                console.error("Erro ao carregar tarefas:", error);
                showToast('Erro ao carregar tarefas.', 'error', 6000);
                showLoadingIndicator(false);
            });
        }
        
        function applyFiltersAndRenderTasks() {
            let tasksToProcess = [...allUserTasks];
            const clientFilter = currentFilters.client.toLowerCase();
            if (clientFilter) {
                tasksToProcess = tasksToProcess.filter(task => task.client && task.client.toLowerCase().includes(clientFilter));
            }
            
            const targetDate = new Date(selectedDateForList + "T00:00:00"); 
            const targetDateStr = selectedDateForList;
            const targetDayOfWeek = targetDate.getDay();

            let activeTasksForDisplay = [];
            let completedTasksForDisplay = []; 

            tasksToProcess.forEach(task => {
                if (task.isRecurring && task.recurrenceStartDate) {
                    const recurrenceStart = new Date(task.recurrenceStartDate + "T00:00:00");
                    if (task.recurrenceEndDate && targetDate > new Date(task.recurrenceEndDate + "T23:59:59")) return; 
                    if (task.skippedDates && task.skippedDates.includes(targetDateStr)) return; 

                    let isInstanceOnSelectedDate = false;
                    if (task.recurrenceType === 'specific_days_of_week' && task.recurrenceDaysOfWeek) {
                        if (targetDate >= recurrenceStart && task.recurrenceDaysOfWeek.includes(targetDayOfWeek)) isInstanceOnSelectedDate = true;
                    } else if (task.recurrenceType === 'every_x_days' && task.recurrenceInterval > 0) {
                        if (targetDate >= recurrenceStart) {
                            const diffTime = Math.abs(targetDate.setHours(0,0,0,0) - recurrenceStart.setHours(0,0,0,0)); 
                            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
                            if (diffDays % task.recurrenceInterval === 0) isInstanceOnSelectedDate = true;
                        }
                    }
                    
                    if (isInstanceOnSelectedDate) {
                        const effectiveTaskInstance = { ...task, effectiveDate: targetDateStr };
                        if (task.completedDates && task.completedDates.includes(targetDateStr)) {
                            completedTasksForDisplay.push({ ...effectiveTaskInstance, displayStatus: 'completed' });
                        } else {
                            activeTasksForDisplay.push({ ...effectiveTaskInstance, displayStatus: task.status });
                        }
                    }
                } else if (!task.isRecurring) { 
                    if (task.dueDate === targetDateStr) { 
                        if (task.status === 'completed') {
                            completedTasksForDisplay.push({ ...task, displayStatus: 'completed' });
                        } else {
                            activeTasksForDisplay.push({ ...task, displayStatus: task.status });
                        }
                    }
                }
            });
            
            let allInstancesForDisplay = [...activeTasksForDisplay, ...completedTasksForDisplay];

            if (currentFilters.status !== 'all') {
                allInstancesForDisplay = allInstancesForDisplay.filter(taskInstance => {
                    if (currentFilters.status === 'completed') return taskInstance.displayStatus === 'completed';
                    if (currentFilters.status === 'overdue') { 
                         const taskDeadline = new Date((taskInstance.dueDate || taskInstance.effectiveDate) + (taskInstance.startTime ? `T${taskInstance.startTime}` : `T23:59:59`));
                         return taskDeadline < new Date() && taskInstance.displayStatus !== 'completed';
                    }
                    if(taskInstance.isRecurring && taskInstance.effectiveDate === targetDateStr && 
                       taskInstance.completedDates && taskInstance.completedDates.includes(targetDateStr) && 
                       currentFilters.status !== 'completed'){
                        return false;
                    }
                    return taskInstance.displayStatus === currentFilters.status;
                 });
            }
            
            const finalDisplayListWithOverdue = allInstancesForDisplay.map(task => {
                let finalStatus = task.displayStatus;
                if (task.isRecurring && task.effectiveDate && task.completedDates && task.completedDates.includes(task.effectiveDate)) {
                    finalStatus = 'completed';
                } else if (finalStatus !== 'completed') { 
                    const checkDate = task.isRecurring ? task.effectiveDate : task.dueDate;
                    if (checkDate) {
                        const taskDeadline = new Date(checkDate + (task.startTime ? `T${task.startTime}` : `T23:59:59`));
                        if (taskDeadline < new Date()) {
                            finalStatus = 'overdue';
                        }
                    }
                }
                return { ...task, displayStatus: finalStatus };
            });

            activeTasksForDisplay = finalDisplayListWithOverdue.filter(t => t.displayStatus !== 'completed');
            completedTasksForDisplay = finalDisplayListWithOverdue.filter(t => t.displayStatus === 'completed');


            if (currentView === 'list') {
                renderTaskList(activeTasksForDisplay); 
                renderCompletedTasks(completedTasksForDisplay); 
            } else if (currentView === 'calendar' && calendar) {
                renderCalendarEvents(allUserTasks); 
            }
        }
        
        applyFiltersButton.addEventListener('click', () => { /* ... (sem alterações) ... */ currentFilters.client = filterClientInput.value.trim(); currentFilters.status = filterStatusSelect.value; applyFiltersAndRenderTasks(); });
        clearFiltersButton.addEventListener('click', () => { /* ... (sem alterações) ... */ filterClientInput.value = ''; filterStatusSelect.value = 'all'; currentFilters.client = ''; currentFilters.status = 'all'; applyFiltersAndRenderTasks(); });

        function renderTaskList(tasksToDisplay) { 
            taskListContainer.innerHTML = '';
            const todayStr = new Date().toISOString().split('T')[0];
            const dateObj = new Date(selectedDateForList + "T00:00:00");
            const formattedDate = selectedDateForList === todayStr ? 
                                  `Hoje, ${dateObj.toLocaleDateString('pt-BR', { weekday: 'long', month: 'long', day: 'numeric' })}` : 
                                  dateObj.toLocaleDateString('pt-BR', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
            taskListDateHeader.textContent = `- ${formattedDate}`;


            if (tasksToDisplay.length === 0) {
                taskListContainer.innerHTML = `<p class="text-gray-400 text-center py-4">Nenhuma tarefa ativa para ${formattedDate.toLowerCase()}.</p>`;
                return;
            }
            
            tasksToDisplay
                .sort((a,b) => (a.startTime || "00:00").localeCompare(b.startTime || "00:00"))
                .forEach(task => taskListContainer.appendChild(createTaskElement(task, selectedDateForList)));
        }

        function renderCompletedTasks(tasksToDisplay) {
            completedTasksListContainer.innerHTML = '';
            const todayStr = new Date().toISOString().split('T')[0];
            const dateObj = new Date(selectedDateForList + "T00:00:00");
            const formattedDate = selectedDateForList === todayStr ? 
                                  `de Hoje` : 
                                  `de ${dateObj.toLocaleDateString('pt-BR', { day: 'numeric', month: 'long' })}`;
            completedTasksDateHeader.textContent = `(${formattedDate})`;


            if (tasksToDisplay.length === 0) {
                completedTasksListContainer.innerHTML = `<p class="text-gray-400 text-center py-2">Nenhuma tarefa concluída para ${formattedDate.toLowerCase()}.</p>`;
                return;
            }
            tasksToDisplay.sort((a, b) => {
                const dateA = a.effectiveDate || a.dueDate || '0';
                const dateB = b.effectiveDate || b.dueDate || '0';
                if (dateA < dateB) return 1; 
                if (dateA > dateB) return -1;
                return (a.startTime || "00:00").localeCompare(b.startTime || "00:00");
            });

            tasksToDisplay.forEach(task => {
                 const instanceDateForCompleted = task.effectiveDate || task.dueDate; 
                completedTasksListContainer.appendChild(createTaskElement(task, instanceDateForCompleted));
            });
        }

        toggleCompletedTasksButton.addEventListener('click', () => {
            completedTasksListContainer.classList.toggle('hidden');
            completedTasksCaret.classList.toggle('fa-chevron-down');
            completedTasksCaret.classList.toggle('fa-chevron-up');
        });


        function createTaskElement(task, instanceDateStr) { 
            const taskElement = document.createElement('div');
            const effectiveStatus = task.displayStatus || task.status; 

            taskElement.className = `p-3 sm:p-4 rounded-lg shadow-md border-l-4 flex flex-col space-y-1 sm:space-y-2 transition-all duration-200 ease-in-out ${getPriorityBorderColor(task.priority)} ${getStatusBgColor(effectiveStatus)}`;
            taskElement.dataset.taskId = task.id;
            if(instanceDateStr) taskElement.dataset.instanceDate = instanceDateStr; 

            const endTime = task.startTime && task.estimatedTime ? getTaskEndTime(task.startTime, task.estimatedTime) : null;
            const timeDisplay = task.startTime ? `${task.startTime}${endTime ? ' - ' + endTime : ''}${task.estimatedTime ? ' ('+task.estimatedTime+' min)' : ''}` : (task.estimatedTime ? `(${task.estimatedTime} min)` : 'Horário indefinido');
            
            let statusText;
            switch(effectiveStatus) {
                case 'pending': statusText = 'Pendente'; break;
                case 'in-progress': statusText = 'Em Andamento'; break;
                case 'paused': statusText = 'Pausada'; break;
                case 'completed': statusText = `Concluída ${task.isRecurring ? '(Instância)' : ''}`; break;
                case 'overdue': statusText = 'Atrasada'; break;
                default: statusText = effectiveStatus; 
            }

            let dateText = '';
            if (task.isRecurring) {
                 let recurrenceInfo = '';
                 if (task.recurrenceType === 'specific_days_of_week' && task.recurrenceDaysOfWeek) {
                    recurrenceInfo = `(${task.recurrenceDaysOfWeek.map(d => daysOfWeekMap[d].name.substring(0,3)).join(', ')})`;
                 } else if (task.recurrenceType === 'every_x_days' && task.recurrenceInterval) {
                    recurrenceInfo = `(a cada ${task.recurrenceInterval} dia${task.recurrenceInterval > 1 ? 's':''})`;
                 }
                 dateText = `<p class="text-xs sm:text-sm text-indigo-300"><i class="fas fa-redo-alt mr-1 sm:mr-2"></i>Recorrente ${recurrenceInfo}</p>`;
                 if (instanceDateStr && instanceDateStr !== new Date().toISOString().split('T')[0]) { 
                     dateText += `<p class="text-xs text-gray-400">Instância de: ${new Date(instanceDateStr+'T00:00:00').toLocaleDateString('pt-BR')}</p>`;
                 }
            } else if (task.dueDate) {
                try { dateText = `<p class="text-xs sm:text-sm text-gray-300"><i class="fas fa-calendar-day mr-1 sm:mr-2"></i>Data: ${new Date(task.dueDate+'T00:00:00').toLocaleDateString('pt-BR')}</p>`;
                } catch (e) { dateText = `<p class="text-xs sm:text-sm">Data: ${task.dueDate}</p>`; }
            }

            let countdownDisplay = '';
            if (effectiveStatus === 'in-progress' && typeof task.remainingSeconds === 'number') {
                const minutes = Math.floor(task.remainingSeconds / 60);
                const seconds = task.remainingSeconds % 60;
                countdownDisplay = `<div class="countdown-timer bg-blue-500 text-white pulsate"><i class="fas fa-hourglass-half mr-1"></i> ${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}</div>`;
            }
            
            let trackedTimeDisplay = '';
            const displayTrackedSeconds = task.timeTrackedSecondsToDisplay !== undefined ? task.timeTrackedSecondsToDisplay : (task.timeTrackedSeconds || 0);
            if (displayTrackedSeconds > 0 || task.isTrackingTime) {
                 trackedTimeDisplay = `<div class="tracked-time-display bg-purple-600 text-white ${task.isTrackingTime ? 'pulsate' : ''}"><i class="fas fa-stopwatch mr-1"></i> ${formatSecondsToHHMMSS(displayTrackedSeconds)}</div>`;
            }


            taskElement.innerHTML = `
                <div class="flex justify-between items-start">
                    <h4 class="text-md sm:text-lg font-semibold text-gray-100 flex-1 break-words">${task.title}</h4>
                    <div class="flex items-center space-x-2"> 
                        ${countdownDisplay}
                        ${trackedTimeDisplay}
                        <button class="edit-task-btn text-gray-400 hover:text-indigo-300 text-sm p-1" title="Editar Tarefa"><i class="fas fa-edit"></i></button>
                    </div>
                </div>
                ${task.client ? `<p class="text-xs sm:text-sm"><i class="fas fa-user-tie mr-1 sm:mr-2"></i>Cliente: ${task.client}</p>` : ''}
                ${task.type ? `<p class="text-xs sm:text-sm"><i class="fas fa-tag mr-1 sm:mr-2"></i>Tipo: ${task.type}</p>` : ''}
                <p class="text-xs sm:text-sm"><i class="fas fa-clock mr-1 sm:mr-2"></i>${timeDisplay}</p>
                ${dateText}
                <p class="text-xs sm:text-sm"><i class="fas fa-info-circle mr-1 sm:mr-2"></i>Status: <span class="font-medium">${statusText}</span></p>
                ${task.description ? `<p class="text-xs text-gray-400 pt-1 border-t border-gray-700 mt-1 whitespace-pre-wrap">${task.description}</p>` : ''}
                <div class="task-actions mt-2 sm:mt-3 flex flex-wrap gap-1 sm:gap-2"></div>`;
            
            const actionsContainer = taskElement.querySelector('.task-actions');
            // Botões de ação para o timer de estimativa
            if (effectiveStatus === 'pending' || effectiveStatus === 'overdue') {
                const startBtn = document.createElement('button'); 
                startBtn.className = 'text-xs bg-blue-600 hover:bg-blue-700 text-white py-1 px-2 rounded shadow'; startBtn.innerHTML = '<i class="fas fa-play mr-1"></i>Iniciar (Estim.)';
                startBtn.title = "Iniciar contagem regressiva baseada no tempo estimado.";
                startBtn.addEventListener('click', (e) => { e.stopPropagation(); handleTaskAction(task.id, 'start', instanceDateStr); }); actionsContainer.appendChild(startBtn);
            }
            if (effectiveStatus === 'in-progress') {
                const pauseBtn = document.createElement('button'); 
                pauseBtn.className = 'text-xs bg-yellow-600 hover:bg-yellow-700 text-white py-1 px-2 rounded shadow'; pauseBtn.innerHTML = '<i class="fas fa-pause mr-1"></i>Pausar (Estim.)';
                pauseBtn.title = "Pausar contagem regressiva.";
                pauseBtn.addEventListener('click', (e) => { e.stopPropagation(); handleTaskAction(task.id, 'pause', instanceDateStr); }); actionsContainer.appendChild(pauseBtn);
            }
            if (effectiveStatus === 'paused') {
                const resumeBtn = document.createElement('button'); 
                resumeBtn.className = 'text-xs bg-blue-600 hover:bg-blue-700 text-white py-1 px-2 rounded shadow'; resumeBtn.innerHTML = '<i class="fas fa-play mr-1"></i>Retomar (Estim.)';
                resumeBtn.title = "Retomar contagem regressiva.";
                resumeBtn.addEventListener('click', (e) => { e.stopPropagation(); handleTaskAction(task.id, 'resume', instanceDateStr); }); actionsContainer.appendChild(resumeBtn);
            }

            // Botões para o cronômetro de trabalho manual
            if (!task.isTrackingTime && effectiveStatus !== 'completed') {
                const startTrackingBtn = document.createElement('button');
                startTrackingBtn.className = 'text-xs bg-green-700 hover:bg-green-800 text-white py-1 px-2 rounded shadow';
                startTrackingBtn.innerHTML = '<i class="fas fa-stopwatch mr-1"></i> Iniciar Cronômetro';
                startTrackingBtn.title = "Iniciar cronômetro de trabalho manual.";
                startTrackingBtn.addEventListener('click', (e) => { e.stopPropagation(); handleTimeTracking(task.id, 'start_manual_tracking', instanceDateStr); });
                actionsContainer.appendChild(startTrackingBtn);
            }
            if (task.isTrackingTime) {
                const stopTrackingBtn = document.createElement('button');
                stopTrackingBtn.className = 'text-xs bg-red-700 hover:bg-red-800 text-white py-1 px-2 rounded shadow';
                stopTrackingBtn.innerHTML = '<i class="fas fa-stop-circle mr-1"></i> Parar Cronômetro';
                stopTrackingBtn.title = "Parar cronômetro de trabalho manual.";
                stopTrackingBtn.addEventListener('click', (e) => { e.stopPropagation(); handleTimeTracking(task.id, 'stop_manual_tracking', instanceDateStr); });
                actionsContainer.appendChild(stopTrackingBtn);
            }


            if (effectiveStatus !== 'completed') {
                const completeBtn = document.createElement('button'); 
                completeBtn.className = 'text-xs bg-green-600 hover:bg-green-700 text-white py-1 px-2 rounded shadow'; completeBtn.innerHTML = '<i class="fas fa-check mr-1"></i>Concluir';
                completeBtn.addEventListener('click', (e) => { e.stopPropagation(); handleTaskAction(task.id, 'complete', instanceDateStr); }); actionsContainer.appendChild(completeBtn);
            }
             if (task.isRecurring && effectiveStatus === 'completed' && instanceDateStr) { 
                const resetBtn = document.createElement('button');
                resetBtn.className = 'text-xs bg-gray-500 hover:bg-gray-600 text-white py-1 px-2 rounded shadow'; resetBtn.innerHTML = '<i class="fas fa-undo mr-1"></i>Desmarcar Concluída';
                resetBtn.addEventListener('click', (e) => { e.stopPropagation(); handleTaskAction(task.id, 'reset_instance_completion', instanceDateStr); }); actionsContainer.appendChild(resetBtn);
            }

            taskElement.querySelector('.edit-task-btn').addEventListener('click', (e) => { 
                e.stopPropagation(); 
                openEditModalWithTask(task, instanceDateStr); 
            });
            return taskElement;
        }
        
        async function handleTaskAction(taskId, action, instanceDate = null) { /* ... (sem alterações) ... */
            if (!tasksCollectionRef) return;
            showLoadingIndicator();
            const taskRef = doc(tasksCollectionRef, taskId);

            let updates = { updatedAt: serverTimestamp() };
            const currentActionDate = instanceDate || new Date().toISOString().split('T')[0];

            try {
                await runTransaction(db, async (transaction) => {
                    const taskDoc = await transaction.get(taskRef);
                    if (!taskDoc.exists()) throw "Tarefa não existe mais.";
                    
                    const currentTaskData = taskDoc.data();
                    let currentRemaining = currentTaskData.remainingSeconds;
                    let currentCompletedDates = Array.isArray(currentTaskData.completedDates) ? [...currentTaskData.completedDates] : [];
                    let currentSkippedDates = Array.isArray(currentTaskData.skippedDates) ? [...currentTaskData.skippedDates] : [];


                    if (action === 'start') {
                        updates.status = 'in-progress';
                        updates.lastStartTime = serverTimestamp();
                        if (currentTaskData.isRecurring) { 
                            if (currentCompletedDates.includes(currentActionDate)) {
                                updates.completedDates = currentCompletedDates.filter(d => d !== currentActionDate);
                            }
                             if (currentSkippedDates.includes(currentActionDate)) { 
                                updates.skippedDates = currentSkippedDates.filter(d => d !== currentActionDate);
                            }
                        }
                        if (typeof currentRemaining !== 'number' || currentRemaining <= 0) {
                             updates.remainingSeconds = (currentTaskData.originalEstimatedTime || currentTaskData.estimatedTime) * 60;
                        }
                    } else if (action === 'pause') {
                        updates.status = 'paused';
                        if (currentTaskData.lastStartTime && currentTaskData.lastStartTime.seconds) {
                            const lastStartMillis = currentTaskData.lastStartTime.toMillis();
                            const nowMillis = Date.now();
                            const elapsedSeconds = Math.floor((nowMillis - lastStartMillis) / 1000);
                            updates.remainingSeconds = Math.max(0, (currentRemaining || 0) - elapsedSeconds);
                        }
                        updates.lastStartTime = null;
                    } else if (action === 'resume') {
                        updates.status = 'in-progress';
                        updates.lastStartTime = serverTimestamp();
                    } else if (action === 'complete') {
                        updates.remainingSeconds = 0;
                        updates.lastStartTime = null;
                        if (currentTaskData.isTrackingTime) {
                            updates.isTrackingTime = false;
                            if (currentTaskData.lastTrackingStartTime && currentTaskData.lastTrackingStartTime.seconds) {
                                const lastTrackStartMillis = currentTaskData.lastTrackingStartTime.toMillis();
                                const nowMillis = Date.now();
                                const elapsedTrackedSeconds = Math.floor((nowMillis - lastTrackStartMillis) / 1000);
                                updates.timeTrackedSeconds = (currentTaskData.timeTrackedSeconds || 0) + elapsedTrackedSeconds;
                            }
                            updates.lastTrackingStartTime = null;
                        }

                        if (currentTaskData.isRecurring) {
                            if (!currentCompletedDates.includes(currentActionDate)) {
                                updates.completedDates = [...currentCompletedDates, currentActionDate];
                            }
                             if (currentSkippedDates.includes(currentActionDate)) { 
                                updates.skippedDates = currentSkippedDates.filter(d => d !== currentActionDate);
                            }
                            updates.status = 'pending'; 
                        } else {
                            updates.status = 'completed';
                        }
                    } else if (action === 'reset_instance_completion' && currentTaskData.isRecurring) {
                        updates.completedDates = currentCompletedDates.filter(d => d !== currentActionDate);
                        updates.status = 'pending'; 
                        updates.remainingSeconds = (currentTaskData.originalEstimatedTime || currentTaskData.estimatedTime) * 60;
                    }
                    transaction.update(taskRef, updates);
                });
                showToast(`Tarefa ${action === 'complete' ? 'concluída' : (action === 'reset_instance_completion' ? 'desmarcada' : 'atualizada')}!`, 'success');
            } catch (error) {
                console.error(`Erro ao ${action} tarefa:`, error);
                showToast(`Erro ao ${action} tarefa.`, 'error', 6000);
            } finally { showLoadingIndicator(false); }
        }
        
        async function handleTimeTracking(taskId, action, instanceDate = null) {
            if (!tasksCollectionRef) return;
            showLoadingIndicator();
            const taskRef = doc(tasksCollectionRef, taskId);
            const currentActionDate = instanceDate || new Date().toISOString().split('T')[0]; 

            try {
                await runTransaction(db, async (transaction) => {
                    const taskDoc = await transaction.get(taskRef);
                    if (!taskDoc.exists()) throw "Tarefa não existe mais.";
                    const currentTaskData = taskDoc.data();
                    let updates = { updatedAt: serverTimestamp() };

                    if (action === 'start_manual_tracking') {
                        updates.isTrackingTime = true;
                        updates.lastTrackingStartTime = serverTimestamp();
                        if (currentTaskData.isRecurring && currentTaskData.skippedDates && currentTaskData.skippedDates.includes(currentActionDate)) {
                            updates.skippedDates = currentTaskData.skippedDates.filter(d => d !== currentActionDate);
                        }

                    } else if (action === 'stop_manual_tracking') {
                        updates.isTrackingTime = false;
                        if (currentTaskData.lastTrackingStartTime && currentTaskData.lastTrackingStartTime.seconds) {
                            const lastTrackStartMillis = currentTaskData.lastTrackingStartTime.toMillis();
                            const nowMillis = Date.now(); 
                            const elapsedSeconds = Math.floor((nowMillis - lastTrackStartMillis) / 1000);
                            updates.timeTrackedSeconds = (currentTaskData.timeTrackedSeconds || 0) + elapsedSeconds;
                        }
                        updates.lastTrackingStartTime = null;
                    }
                    transaction.update(taskRef, updates);
                });
                showToast(`Cronômetro ${action === 'start_manual_tracking' ? 'iniciado' : 'parado'}!`, 'success');
            } catch (error) {
                console.error("Erro ao controlar cronômetro:", error);
                showToast("Erro ao controlar cronômetro.", "error");
            } finally {
                showLoadingIndicator(false);
            }
        }


        function getPriorityBorderColor(priority) { /* ... (sem alterações) ... */ switch(priority){ case 'urgent': return 'border-red-500'; case 'high': return 'border-orange-500'; case 'medium': return 'border-yellow-500'; case 'low': return 'border-blue-500'; default: return 'border-gray-600';}}
        function getPriorityCalendarColor(priority) { /* ... (sem alterações) ... */ switch(priority){ case 'urgent': return {backgroundColor:'#ef4444',borderColor:'#ef4444'}; case 'high': return {backgroundColor:'#f97316',borderColor:'#f97316'}; case 'medium': return {backgroundColor:'#eab308',borderColor:'#eab308'}; case 'low': return {backgroundColor:'#3b82f6',borderColor:'#3b82f6'}; default: return {backgroundColor:'#6b7280',borderColor:'#6b7280'};}}
        function getStatusBgColor(status) { /* ... (sem alterações) ... */ switch(status){ case 'pending': return 'bg-gray-700 hover:bg-gray-600/80'; case 'in-progress': return 'bg-blue-700 hover:bg-blue-600/80'; case 'paused': return 'bg-yellow-700 hover:bg-yellow-600/80'; case 'completed': return 'bg-green-700 hover:bg-green-600/80 opacity-80'; case 'overdue': return 'bg-red-700 hover:bg-red-600/80'; default: return 'bg-gray-750 hover:bg-gray-650/80';}}


        function openEditModalWithTask(task, instanceDate = null) {
            editTaskIdInput.value = task.id;
            editTaskInstanceDateInput.value = instanceDate || ''; 
            editTaskTitleInput.value = task.title;
            editTaskClientInput.value = task.client || '';
            editTaskTypeInput.value = task.type || '';
            editTaskPriorityInput.value = task.priority;
            editTaskEstimatedTimeInput.value = task.originalEstimatedTime || task.estimatedTime || '';
            
            editTaskIsRecurringCheckbox.checked = task.isRecurring || false;
            if (task.isRecurring) {
                editTaskRecurrenceStartDateInput.value = task.recurrenceStartDate || '';
                editTaskRecurrenceTypeSelect.value = task.recurrenceType || 'specific_days_of_week';
                
                if (task.recurrenceType === 'specific_days_of_week') {
                    document.querySelectorAll('#editTaskRecurrenceDaysOfWeek input[type="checkbox"]').forEach(cb => {
                        cb.checked = task.recurrenceDaysOfWeek && task.recurrenceDaysOfWeek.includes(parseInt(cb.value));
                    });
                    editTaskRecurrenceIntervalInput.value = ''; 
                } else if (task.recurrenceType === 'every_x_days') {
                    editTaskRecurrenceIntervalInput.value = task.recurrenceInterval || '';
                    document.querySelectorAll('#editTaskRecurrenceDaysOfWeek input[type="checkbox"]').forEach(cb => cb.checked = false); 
                }
            } else {
                editTaskDueDateInput.value = task.dueDate || '';
                document.querySelectorAll('#editTaskRecurrenceDaysOfWeek input[type="checkbox"]').forEach(cb => cb.checked = false);
                editTaskRecurrenceStartDateInput.value = '';
                editTaskRecurrenceIntervalInput.value = '';
                editTaskRecurrenceTypeSelect.value = 'specific_days_of_week'; 
            }
            
            editTaskStartTimeInput.value = task.startTime || '';
            editTaskStatusInput.value = task.status; 
            editTaskDescriptionInput.value = task.description || '';

            editTaskIsRecurringCheckbox.dispatchEvent(new Event('change')); 
            editTaskRecurrenceTypeSelect.dispatchEvent(new Event('change')); 
            editTaskModal.classList.remove('hidden');
        }

        closeEditTaskModalButton.addEventListener('click', () => editTaskModal.classList.add('hidden'));
        editTaskModal.addEventListener('click', (event) => {
            if (event.target === editTaskModal) { 
                editTaskModal.classList.add('hidden');
            }
        });


        editTaskForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            if (!tasksCollectionRef) return;
            const taskId = editTaskIdInput.value;
            if (!taskId) { showToast('ID da tarefa não encontrado.', 'error'); return; }
            
            const title = editTaskTitleInput.value.trim();
            const estimatedTime = editTaskEstimatedTimeInput.value ? parseInt(editTaskEstimatedTimeInput.value) : 0;
            const isRecurring = editTaskIsRecurringCheckbox.checked;
            const startTime = editTaskStartTimeInput.value || null;

            if (!title || estimatedTime <= 0 || !startTime) { showToast("Título, tempo estimado > 0 e hora de início são obrigatórios.", "error"); return; }

            let updatedData = {
                title: title, client: editTaskClientInput.value.trim() || null, type: editTaskTypeInput.value.trim() || null,
                priority: editTaskPriorityInput.value, estimatedTime: estimatedTime, originalEstimatedTime: estimatedTime, 
                startTime: startTime, status: editTaskStatusInput.value, description: editTaskDescriptionInput.value.trim() || null,
                updatedAt: serverTimestamp(), isRecurring: isRecurring,
                recurrenceType: null, recurrenceDaysOfWeek: null, recurrenceStartDate: null, recurrenceInterval: null, recurrenceEndDate: null, dueDate: null,
            };

            const originalTask = allUserTasks.find(t => t.id === taskId);
            if (originalTask) {
                updatedData.skippedDates = originalTask.skippedDates || []; 
                updatedData.timeTrackedSeconds = originalTask.timeTrackedSeconds || 0;
                updatedData.isTrackingTime = originalTask.isTrackingTime || false;
                updatedData.lastTrackingStartTime = originalTask.lastTrackingStartTime || null;
                updatedData.recurrenceEndDate = originalTask.recurrenceEndDate || null; 
            }


            if (isRecurring) {
                updatedData.recurrenceType = editTaskRecurrenceTypeSelect.value;
                const recStartDate = editTaskRecurrenceStartDateInput.value;
                if (!recStartDate) { showToast("Data de início da recorrência é obrigatória.", "error"); return; }
                updatedData.recurrenceStartDate = recStartDate;

                if (updatedData.recurrenceType === 'specific_days_of_week') {
                    const selectedDays = Array.from(editTaskRecurrenceDaysOfWeekDiv.querySelectorAll('input[type="checkbox"]:checked')).map(cb => parseInt(cb.value));
                    if (selectedDays.length === 0) { showToast("Selecione dias para recorrência semanal.", "error"); return; }
                    updatedData.recurrenceDaysOfWeek = selectedDays;
                    updatedData.recurrenceInterval = null; 
                } else if (updatedData.recurrenceType === 'every_x_days') {
                    const interval = parseInt(editTaskRecurrenceIntervalInput.value);
                    if (!interval || interval <= 0) { showToast("Intervalo de dias deve ser maior que zero.", "error"); return; }
                    updatedData.recurrenceInterval = interval;
                    updatedData.recurrenceDaysOfWeek = null; 
                }
            } else {
                const dueDate = editTaskDueDateInput.value;
                if (!dueDate) { showToast("Data é obrigatória para tarefas não recorrentes.", "error"); return; }
                updatedData.dueDate = dueDate;
                updatedData.recurrenceType = null; updatedData.recurrenceDaysOfWeek = null; updatedData.recurrenceStartDate = null;
                updatedData.recurrenceInterval = null; updatedData.recurrenceEndDate = null; 
                updatedData.completedDates = []; updatedData.skippedDates = [];
            }
            
            if (originalTask && (originalTask.status !== 'pending' && updatedData.status === 'pending') ||
                (originalTask.estimatedTime !== updatedData.estimatedTime && updatedData.status !== 'completed')) {
                updatedData.remainingSeconds = updatedData.estimatedTime * 60;
                updatedData.lastStartTime = null;
            }
            
            if (isRecurring) {
                let patternChanged = true; 
                if (originalTask && originalTask.isRecurring && originalTask.recurrenceType === updatedData.recurrenceType) {
                    if (updatedData.recurrenceType === 'specific_days_of_week' &&
                        JSON.stringify(originalTask.recurrenceDaysOfWeek) === JSON.stringify(updatedData.recurrenceDaysOfWeek) &&
                        originalTask.recurrenceStartDate === updatedData.recurrenceStartDate) {
                        patternChanged = false;
                    } else if (updatedData.recurrenceType === 'every_x_days' &&
                               originalTask.recurrenceInterval === updatedData.recurrenceInterval &&
                               originalTask.recurrenceStartDate === updatedData.recurrenceStartDate) {
                        patternChanged = false;
                    }
                }
                updatedData.completedDates = patternChanged ? [] : (originalTask.completedDates || []);
                updatedData.skippedDates = patternChanged ? [] : (originalTask.skippedDates || []); 
            }


            showLoadingIndicator();
            const conflicts = await checkConflicts(updatedData, allUserTasks, taskId);
            if (conflicts.length > 0) {
                const conflictMessages = conflicts.map(c => `'${c.title}'`).join(', ');
                showToast(`Conflito: ${conflictMessages}. Ajuste.`, 'error', 7000);
                showLoadingIndicator(false); return;
            }

            const taskRef = doc(tasksCollectionRef, taskId);
            try {
                await updateDoc(taskRef, updatedData);
                showToast('Tarefa atualizada!', 'success');
                editTaskModal.classList.add('hidden');
            } catch (error) { console.error("Erro ao atualizar tarefa:", error); showToast('Erro ao atualizar tarefa.', 'error');
            } finally { showLoadingIndicator(false); }
        });

        triggerDeleteTaskButton.addEventListener('click', () => {
            taskToDeleteId = editTaskIdInput.value; 
            instanceDateToDelete = editTaskInstanceDateInput.value || new Date().toISOString().split('T')[0]; 
            
            const task = allUserTasks.find(t => t.id === taskToDeleteId);
            if (!task) {
                showToast('Tarefa não encontrada para exclusão.', 'error');
                return;
            }

            if (task.isRecurring) {
                // Passar a data da instância para o modal de opções
                document.getElementById('deleteThisInstanceButton').dataset.instanceDate = instanceDateToDelete;
                document.getElementById('deleteFutureInstancesButton').dataset.instanceDate = instanceDateToDelete;
                deleteRecurrenceOptionsModal.classList.remove('hidden');
            } else {
                openConfirmationModal(
                    'Excluir Tarefa', 
                    'Tem certeza que deseja excluir esta tarefa? Esta ação não pode ser desfeita.', 
                    () => deleteTask(taskToDeleteId) 
                );
            }
        });

        async function deleteTask(taskId, deleteOption = 'all', instanceDate = null) {
            if (!tasksCollectionRef || !taskId) return;
            showLoadingIndicator();
            const taskRef = doc(tasksCollectionRef, taskId);

            try {
                if (deleteOption === 'this_instance' && instanceDate) {
                    const taskDoc = await getDoc(taskRef);
                    if (taskDoc.exists()) {
                        const taskData = taskDoc.data();
                        const skippedDates = Array.isArray(taskData.skippedDates) ? [...taskData.skippedDates] : [];
                        if (!skippedDates.includes(instanceDate)) {
                            skippedDates.push(instanceDate);
                        }
                        const completedDates = (Array.isArray(taskData.completedDates) ? taskData.completedDates : []).filter(d => d !== instanceDate);

                        await updateDoc(taskRef, { skippedDates: skippedDates, completedDates: completedDates, updatedAt: serverTimestamp() });
                        showToast('Ocorrência da tarefa excluída/pulada.', 'success');
                    } else {
                        throw new Error("Tarefa não encontrada para atualizar skippedDates.");
                    }
                } else if (deleteOption === 'future_instances' && instanceDate) {
                    const previousDay = new Date(instanceDate + "T00:00:00");
                    previousDay.setDate(previousDay.getDate() - 1);
                    const recurrenceEndDate = previousDay.toISOString().split('T')[0];
                    await updateDoc(taskRef, { recurrenceEndDate: recurrenceEndDate, updatedAt: serverTimestamp() });
                    showToast('Esta e futuras ocorrências foram excluídas.', 'success');

                } else { 
                    await deleteDoc(taskRef);
                    showToast('Tarefa e todas as suas ocorrências foram excluídas.', 'success');
                }
                editTaskModal.classList.add('hidden');
                deleteRecurrenceOptionsModal.classList.add('hidden');
            } catch (error) {
                console.error("Erro ao excluir tarefa:", error);
                showToast('Erro ao excluir tarefa.', 'error', 6000);
            } finally {
                showLoadingIndicator(false);
                taskToDeleteId = null;
                instanceDateToDelete = null;
            }
        }
        
        deleteThisInstanceButton.addEventListener('click', () => deleteTask(taskToDeleteId, 'this_instance', deleteThisInstanceButton.dataset.instanceDate));
        deleteFutureInstancesButton.addEventListener('click', () => deleteTask(taskToDeleteId, 'future_instances', deleteFutureInstancesButton.dataset.instanceDate));
        deleteAllInstancesButton.addEventListener('click', () => deleteTask(taskToDeleteId, 'all'));
        cancelDeleteRecurrenceButton.addEventListener('click', () => {
            deleteRecurrenceOptionsModal.classList.add('hidden');
            taskToDeleteId = null;
            instanceDateToDelete = null;
        });


        clearCompletedTasksButton.addEventListener('click', () => { 
            openConfirmationModal('Limpar Histórico de Conclusão', 'Limpar tarefas não recorrentes concluídas e histórico de conclusão de instâncias recorrentes passadas?',
                async () => {
                    showLoadingIndicator(); const batch = writeBatch(db); let itemsAffected = 0;
                    const todayStr = new Date().toISOString().split('T')[0];

                    allUserTasks.forEach(task => {
                        if (task.status === 'completed' && !task.isRecurring) { 
                            batch.delete(doc(tasksCollectionRef, task.id)); itemsAffected++;
                        } else if (task.isRecurring && Array.isArray(task.completedDates) && task.completedDates.length > 0) {
                            const futureCompletedDates = task.completedDates.filter(dateStr => dateStr >= todayStr);
                            if (futureCompletedDates.length < task.completedDates.length) { 
                                batch.update(doc(tasksCollectionRef, task.id), { completedDates: futureCompletedDates, updatedAt: serverTimestamp() });
                                itemsAffected++; 
                            }
                        }
                    });
                    if (itemsAffected === 0) { showToast('Nenhum histórico para limpar.', 'info'); showLoadingIndicator(false); return; }
                    try { await batch.commit(); showToast(`${itemsAffected} itens tiveram seu histórico de conclusão limpo.`, 'success');
                    } catch (error) { console.error("Erro limpar concluídas:", error); showToast('Erro ao limpar.', 'error');
                    } finally { showLoadingIndicator(false); }
                });
        });

        // --- Countdown Timer Logic & Global Update Loop ---
        function startGlobalCountdownTimer() { /* ... (ajustado para cronômetro manual) ... */
            if (countdownInterval) clearInterval(countdownInterval);
            if (activeTaskTimerInterval) clearInterval(activeTaskTimerInterval);

            const updateTimers = () => {
                let tasksNeedRerender = false;
                const now = Date.now();
                allUserTasks.forEach(task => {
                    // Timer regressivo (estimado)
                    if (task.status === 'in-progress' && task.lastStartTime && task.lastStartTime.seconds) {
                        const lastStartMillis = task.lastStartTime.toMillis();
                        const elapsedSinceLastStartSeconds = Math.floor((now - lastStartMillis) / 1000);
                        const currentDisplayRemaining = Math.max(0, task.remainingSeconds - elapsedSinceLastStartSeconds);
                        if (task.displayRemainingSeconds !== currentDisplayRemaining) { 
                             task.displayRemainingSeconds = currentDisplayRemaining; 
                             tasksNeedRerender = true;
                        }
                    } else if (task.status !== 'in-progress' && task.displayRemainingSeconds !== undefined) {
                        delete task.displayRemainingSeconds;
                        tasksNeedRerender = true;
                    }

                    // Cronômetro de trabalho manual
                    if (task.isTrackingTime && task.lastTrackingStartTime && task.lastTrackingStartTime.seconds) {
                        const lastTrackStartMillis = task.lastTrackingStartTime.toMillis();
                        const elapsedTrackedSeconds = Math.floor((now - lastTrackStartMillis) / 1000);
                        task.currentTrackedDisplaySeconds = (task.timeTrackedSeconds || 0) + elapsedTrackedSeconds;
                        tasksNeedRerender = true;
                    } else if (!task.isTrackingTime && task.currentTrackedDisplaySeconds !== undefined) {
                        if(task.currentTrackedDisplaySeconds !== (task.timeTrackedSeconds || 0) && (task.timeTrackedSeconds || 0) > 0) {
                             task.currentTrackedDisplaySeconds = task.timeTrackedSeconds || 0;
                             tasksNeedRerender = true;
                        } else if (!task.timeTrackedSeconds && task.currentTrackedDisplaySeconds !== undefined) {
                             delete task.currentTrackedDisplaySeconds;
                             tasksNeedRerender = true;
                        }
                    }
                });
                if (tasksNeedRerender) { 
                    const { activeTasks, completedTasks } = getFilteredTasksForDisplay();
                    if (currentView === 'list') {
                        renderTaskList(activeTasks);
                        renderCompletedTasks(completedTasks);
                    }
                }
            };
            
            countdownInterval = setInterval(updateTimers, 1000); // Atualiza a cada segundo
        }
        function getFilteredTasksForDisplay() { /* ... (atualizado para every_x_days e skippedDates) ... */
            let tasksToProcess = [...allUserTasks];
            const clientFilter = currentFilters.client.toLowerCase();
            if (clientFilter) tasksToProcess = tasksToProcess.filter(t => t.client && t.client.toLowerCase().includes(clientFilter));
            
            const targetDate = new Date(selectedDateForList + "T00:00:00"); // Usa a data selecionada
            const targetDateStr = selectedDateForList;
            const targetDayOfWeek = targetDate.getDay();

            let effectiveTasks = [];

            tasksToProcess.forEach(task => {
                if (task.isRecurring && task.recurrenceStartDate) {
                    const recurrenceStart = new Date(task.recurrenceStartDate + "T00:00:00");
                     if (task.recurrenceEndDate && targetDate > new Date(task.recurrenceEndDate + "T23:59:59")) return; 
                     if (task.skippedDates && task.skippedDates.includes(targetDateStr)) return; 

                    let isInstanceOnSelectedDate = false;
                    if (task.recurrenceType === 'specific_days_of_week' && task.recurrenceDaysOfWeek) {
                        if (targetDate >= recurrenceStart && task.recurrenceDaysOfWeek.includes(targetDayOfWeek)) isInstanceOnSelectedDate = true;
                    } else if (task.recurrenceType === 'every_x_days' && task.recurrenceInterval > 0) {
                        if (targetDate >= recurrenceStart) {
                            const diffTime = Math.abs(targetDate.setHours(0,0,0,0) - recurrenceStart.setHours(0,0,0,0)); 
                            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
                            if (diffDays % task.recurrenceInterval === 0) isInstanceOnSelectedDate = true;
                        }
                    }
                    if (isInstanceOnSelectedDate) {
                        const isCompletedInstance = task.completedDates && task.completedDates.includes(targetDateStr);
                        effectiveTasks.push({ ...task, effectiveDate: targetDateStr, isCompletedInstance });
                    }
                } else if (!task.isRecurring) {
                     if (task.dueDate === targetDateStr) { // Somente tarefas não recorrentes da data selecionada
                        effectiveTasks.push({ ...task });
                    }
                }
            });

            // Mapeia para o status de exibição final antes de filtrar
            let tasksWithFinalStatus = effectiveTasks.map(et => {
                let finalStatus = et.isCompletedInstance ? 'completed' : et.status;
                 if (finalStatus !== 'completed') {
                    const checkDate = et.effectiveDate || et.dueDate;
                    if (checkDate) {
                        const deadline = new Date(checkDate + (et.startTime ? `T${et.startTime}` : `T23:59:59`));
                        if (deadline < new Date()) finalStatus = 'overdue';
                    }
                }
                const displaySeconds = et.displayRemainingSeconds !== undefined ? et.displayRemainingSeconds : et.remainingSeconds;
                const currentTrackedSeconds = et.currentTrackedDisplaySeconds !== undefined ? et.currentTrackedDisplaySeconds : (et.timeTrackedSeconds || 0);
                return { ...et, displayStatus: finalStatus, remainingSeconds: displaySeconds, timeTrackedSecondsToDisplay: currentTrackedSeconds };
            });


            if (currentFilters.status !== 'all') { 
                tasksWithFinalStatus = tasksWithFinalStatus.filter(taskWithStatus => {
                    if (currentFilters.status === 'completed') return taskWithStatus.displayStatus === 'completed';
                    if (currentFilters.status === 'overdue') return taskWithStatus.displayStatus === 'overdue';
                    if (taskWithStatus.isCompletedInstance && currentFilters.status !== 'completed') return false;
                    return taskWithStatus.displayStatus === currentFilters.status;
                });
            }
            
            const activeTasks = tasksWithFinalStatus.filter(t => t.displayStatus !== 'completed');
            const completedTasks = tasksWithFinalStatus.filter(t => t.displayStatus === 'completed');
            
            return { activeTasks, completedTasks };
        }
        function stopGlobalCountdownTimer() { if (countdownInterval) clearInterval(countdownInterval); countdownInterval = null; if (activeTaskTimerInterval) clearInterval(activeTaskTimerInterval); activeTaskTimerInterval = null; }


        // --- Lógica do Calendário (FullCalendar) ---
        function initializeCalendar() { 
            if (calendar) calendar.destroy(); 
            const calEl = document.getElementById('calendarContainer'); 
            if (!calEl) {console.error("Elemento do calendário não encontrado."); return;}

            calendar = new FullCalendar.Calendar(calEl, {
                locale: 'pt-br', initialView: 'dayGridMonth', 
                headerToolbar: {left:'prev,next today',center:'title',right:'dayGridMonth,timeGridWeek,timeGridDay,listWeek'},
                buttonText: {today:'Hoje',month:'Mês',week:'Semana',day:'Dia',list:'Lista'},
                editable:true, selectable:true, dayMaxEvents:true, events:[],
                eventTimeFormat:{hour:'2-digit',minute:'2-digit',meridiem:false,hour12:false},
                slotLabelFormat:{hour:'2-digit',minute:'2-digit',meridiem:false,hour12:false},
                eventClick: function(info) {
                    hideCalendarEventQuickActions(); 
                    const taskOriginalId = info.event.extendedProps.originalId || info.event.id;
                    const taskData = allUserTasks.find(t => t.id === taskOriginalId);
                    const instanceDate = info.event.extendedProps.instanceDate || (taskData && !taskData.isRecurring ? taskData.dueDate : new Date().toISOString().split('T')[0]);

                    if (taskData) {
                        showCalendarEventQuickActions(info.jsEvent, taskData, instanceDate);
                    } else {
                        console.warn("Dados da tarefa não encontrados para o evento clicado:", info.event);
                        const directTask = allUserTasks.find(t => t.id === info.event.id);
                        if (directTask) openEditModalWithTask(directTask, instanceDate);
                    }
                },
                dateClick: (info) => {
                    hideCalendarEventQuickActions();
                    selectedDateForList = info.dateStr; // Atualiza a data selecionada para a lista

                    // Remove a classe de destaque de qualquer dia anteriormente selecionado
                    document.querySelectorAll('.fc-day.calendar-day-selected').forEach(el => {
                        el.classList.remove('calendar-day-selected');
                    });
                    // Adiciona a classe de destaque ao dia clicado
                    info.dayEl.classList.add('calendar-day-selected');


                    if (taskIsRecurringCheckbox.checked) { // Se estiver adicionando uma nova tarefa recorrente
                        taskRecurrenceStartDateInput.value = info.dateStr;
                    } else if (!taskIsRecurringCheckbox.checked && addTaskForm.contains(taskDueDateInput)) { // Se adicionando tarefa não recorrente
                         taskDueDateInput.value = info.dateStr;
                    }
                    
                    if (currentView === 'list') { // Se a visualização de lista estiver ativa, atualize-a
                        applyFiltersAndRenderTasks();
                    } else { // Se não, apenas um toast para feedback
                        showToast(`Data ${info.dateStr} selecionada.`, 'info');
                    }
                },
                eventDrop: async (info) => { 
                    hideCalendarEventQuickActions();
                    const originalTaskId = info.event.extendedProps.originalId || info.event.id;
                    const originalTask = allUserTasks.find(t => t.id === originalTaskId);
                    const originalInstanceDate = info.event.extendedProps.instanceDate || (originalTask && !originalTask.isRecurring ? originalTask.dueDate : null);
                     const oldEventOriginalDate = info.oldEvent && info.oldEvent.start ? info.oldEvent.start.toISOString().split('T')[0] : originalInstanceDate;


                    if (!originalTask) { 
                        showToast("Tarefa original não encontrada para reagendar.", "error");
                        info.revert(); 
                        return; 
                    }

                    const newStart = info.event.start;
                    const newDateStr = newStart.toISOString().split('T')[0];
                    let newStartTime = null;
                    if (!info.event.allDay && newStart.toTimeString().includes(':')) {
                       newStartTime = `${String(newStart.getHours()).padStart(2, '0')}:${String(newStart.getMinutes()).padStart(2, '0')}`;
                    } else if (originalTask.startTime) { 
                        newStartTime = originalTask.startTime;
                    }


                    if (originalTask.isRecurring) {
                        const newOneOffTaskData = {
                            ...originalTask, 
                            title: `(Reagendado) ${originalTask.title}`,
                            isRecurring: false,
                            recurrenceType: null, recurrenceDaysOfWeek: null, recurrenceStartDate: null, recurrenceInterval: null, recurrenceEndDate: null,
                            dueDate: newDateStr,
                            startTime: newStartTime || originalTask.startTime, 
                            status: 'pending', 
                            createdAt: serverTimestamp(),
                            updatedAt: serverTimestamp(),
                            completedDates: [], 
                            skippedDates: [],
                            originalRecurringTaskId: originalTask.id, 
                            remainingSeconds: originalTask.originalEstimatedTime * 60,
                            lastStartTime: null,
                            timeTrackedSeconds: 0,
                            isTrackingTime: false,
                            lastTrackingStartTime: null,
                        };
                        delete newOneOffTaskData.id; 

                        const conflicts = await checkConflicts(newOneOffTaskData, allUserTasks);
                        if (conflicts.length > 0) {
                            showToast(`Conflito ao reagendar instância: ${conflicts.map(c => `'${c.title}' em ${c.conflictDate || c.dueDate }`).join(',')}.`, 'error', 7000);
                            info.revert();
                            return;
                        }
                        
                        showLoadingIndicator();
                        try {
                            await addDoc(tasksCollectionRef, newOneOffTaskData);
                            
                            const taskRef = doc(tasksCollectionRef, originalTask.id);
                            const taskDoc = await getDoc(taskRef); 
                            if(taskDoc.exists()){
                                const currentData = taskDoc.data();
                                const updatedSkippedDates = Array.isArray(currentData.skippedDates) ? [...currentData.skippedDates] : [];
                                if (oldEventOriginalDate && !updatedSkippedDates.includes(oldEventOriginalDate)) {
                                    updatedSkippedDates.push(oldEventOriginalDate);
                                }
                                await updateDoc(taskRef, { skippedDates: updatedSkippedDates, updatedAt: serverTimestamp() });
                            }
                            showToast('Instância recorrente reagendada como uma nova tarefa!', 'success');
                        } catch (error) {
                             console.error("Erro ao reagendar instância recorrente:", error);
                             showToast('Erro ao reagendar instância.', 'error');
                             info.revert();
                        } finally {
                            showLoadingIndicator(false);
                        }

                    } else { // Tarefa não recorrente
                        const updatedDataForConflictCheck = { ...originalTask, dueDate: newDateStr, startTime: newStartTime };
                        const conflicts = await checkConflicts(updatedDataForConflictCheck, allUserTasks, originalTask.id);
                        if (conflicts.length > 0) { showToast(`Conflito ao reagendar: '${conflicts[0].title}'.`, 'error'); info.revert(); return; }

                        if (tasksCollectionRef) {
                            showLoadingIndicator(); const taskRef = doc(tasksCollectionRef, originalTask.id);
                            try { await updateDoc(taskRef, { dueDate:newDateStr,startTime:newStartTime,updatedAt:serverTimestamp()}); showToast('Tarefa reagendada!', 'success');
                            } catch (error) { console.error("Erro reagendar:", error); showToast('Erro ao reagendar.', 'error'); info.revert(); 
                            } finally { showLoadingIndicator(false); }
                        }
                    }
                },
            });
            if (currentView === 'calendar') calendar.render();
        }

        function renderCalendarEvents(baseTasks) { /* ... (atualizado para every_x_days e skippedDates) ... */
            if (!calendar) return;
            calendar.removeAllEvents(); 
            const view = calendar.view;
            const viewStart = new Date(view.activeStart);
            const viewEnd = new Date(view.activeEnd);
            const calendarEvents = [];

            baseTasks.forEach(task => {
                const priorityColors = getPriorityCalendarColor(task.priority);
                if (task.isRecurring && task.recurrenceStartDate) {
                    let currentDateIter = new Date(task.recurrenceStartDate + "T00:00:00");
                    const recurrenceEndDate = task.recurrenceEndDate ? new Date(task.recurrenceEndDate + "T23:59:59") : null;

                    if (currentDateIter < viewStart) {
                        if (task.recurrenceType === 'every_x_days' && task.recurrenceInterval > 0) {
                            const diffDaysToViewStart = Math.floor((viewStart - currentDateIter) / (1000 * 60 * 60 * 24));
                            const intervalsToSkip = Math.floor(diffDaysToViewStart / task.recurrenceInterval);
                            currentDateIter.setDate(currentDateIter.getDate() + intervalsToSkip * task.recurrenceInterval);
                        } else { 
                             currentDateIter = new Date(Math.max(viewStart.getTime(), currentDateIter.getTime()));
                             currentDateIter.setHours(0,0,0,0);
                        }
                    }

                    while(currentDateIter <= viewEnd) {
                        if (recurrenceEndDate && currentDateIter > recurrenceEndDate) break; 

                        const dayStr = currentDateIter.toISOString().split('T')[0];
                        let isInstanceDay = false;

                        if (task.recurrenceType === 'specific_days_of_week' && task.recurrenceDaysOfWeek) {
                            if (currentDateIter >= new Date(task.recurrenceStartDate + "T00:00:00") && task.recurrenceDaysOfWeek.includes(currentDateIter.getDay())) {
                                isInstanceDay = true;
                            }
                        } else if (task.recurrenceType === 'every_x_days' && task.recurrenceInterval > 0) {
                            if (currentDateIter >= new Date(task.recurrenceStartDate + "T00:00:00")) {
                                const diffTime = Math.abs(currentDateIter.setHours(0,0,0,0) - new Date(task.recurrenceStartDate + "T00:00:00").setHours(0,0,0,0));
                                const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
                                if (diffDays % task.recurrenceInterval === 0) {
                                    isInstanceDay = true;
                                }
                            }
                        }
                        
                        if (isInstanceDay && (!task.completedDates || !task.completedDates.includes(dayStr)) && (!task.skippedDates || !task.skippedDates.includes(dayStr))) {
                            const [hours, minutes] = task.startTime.split(':').map(Number);
                            let startDateTime = new Date(currentDateIter); 
                            startDateTime.setHours(hours, minutes, 0, 0);
                            let endDateTime = new Date(startDateTime.getTime() + task.estimatedTime * 60000);

                            calendarEvents.push({
                                id: task.id + '_' + dayStr, 
                                groupId: task.id, 
                                title: task.title,
                                start: startDateTime.toISOString(), end: endDateTime.toISOString(),
                                allDay: false, backgroundColor: priorityColors.backgroundColor, borderColor: priorityColors.borderColor,
                                textColor: '#FFFFFF', extendedProps: { ...task, originalId: task.id, instanceDate: dayStr } 
                            });
                        }
                        currentDateIter.setDate(currentDateIter.getDate() + 1);
                    }
                } else if (!task.isRecurring && task.dueDate) { 
                    if (task.status === 'completed') return; 
                    let startDateTime, endDateTime;
                    if (task.startTime) {
                        startDateTime = `${task.dueDate}T${task.startTime}`;
                        endDateTime = task.estimatedTime ? new Date(new Date(startDateTime).getTime() + task.estimatedTime * 60000).toISOString().slice(0,16) : null;
                    } else { startDateTime = task.dueDate; endDateTime = null; } 
                    
                    if (startDateTime) {
                        calendarEvents.push({
                            id: task.id, title: task.title, start: startDateTime, end: endDateTime, 
                            allDay: !task.startTime, backgroundColor: priorityColors.backgroundColor, borderColor: priorityColors.borderColor,
                            textColor: '#FFFFFF', extendedProps: { ...task, instanceDate: task.dueDate } 
                        });
                    }
                }
            });
            calendar.addEventSource(calendarEvents);
            if (currentView === 'calendar' && calendar && !calendarContainer.classList.contains('hidden')) calendar.render();
        }


        // --- Conflict Detection ---
        async function checkConflicts(taskData, allTasks, ignoreTaskId = null) { /* ... (atualizado para every_x_days e skippedDates) ... */
            const conflicts = [];
            if (!taskData.startTime) return conflicts; 

            const checkOverlapOnDate = (dateStr, startTime1, duration1, startTime2, duration2) => {
                const start1 = new Date(`${dateStr}T${startTime1}`);
                const end1 = new Date(start1.getTime() + duration1 * 60000);
                const start2 = new Date(`${dateStr}T${startTime2}`);
                const end2 = new Date(start2.getTime() + duration2 * 60000);
                return start1 < end2 && end1 > start2;
            };
            
            const conflictSearchRangeDays = 90; 
            const todayForSearch = new Date(); 
            todayForSearch.setHours(0,0,0,0);

            for (let dayOffset = 0; dayOffset < conflictSearchRangeDays; dayOffset++) {
                let currentDateToCheck = new Date(todayForSearch);
                currentDateToCheck.setDate(todayForSearch.getDate() + dayOffset);
                const currentDateStr = currentDateToCheck.toISOString().split('T')[0];
                const currentDayOfWeek = currentDateToCheck.getDay();

                let taskDataIsInstanceOnThisDay = false;
                if (taskData.isRecurring && taskData.recurrenceStartDate) {
                    const recStartDate = new Date(taskData.recurrenceStartDate + "T00:00:00");
                     if (taskData.recurrenceEndDate && currentDateToCheck > new Date(taskData.recurrenceEndDate + "T23:59:59")) continue; 
                     if (taskData.skippedDates && taskData.skippedDates.includes(currentDateStr)) continue; 

                    if (currentDateToCheck >= recStartDate) {
                        if (taskData.recurrenceType === 'specific_days_of_week' && taskData.recurrenceDaysOfWeek && taskData.recurrenceDaysOfWeek.includes(currentDayOfWeek)) {
                            taskDataIsInstanceOnThisDay = true;
                        } else if (taskData.recurrenceType === 'every_x_days' && taskData.recurrenceInterval > 0) {
                            const diffTime = currentDateToCheck.getTime() - recStartDate.getTime();
                            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
                            if (diffDays >= 0 && diffDays % taskData.recurrenceInterval === 0) taskDataIsInstanceOnThisDay = true;
                        }
                    }
                } else if (!taskData.isRecurring) { 
                    if (taskData.dueDate === currentDateStr) taskDataIsInstanceOnThisDay = true;
                }
                if (!taskDataIsInstanceOnThisDay || (taskData.isRecurring && taskData.completedDates && taskData.completedDates.includes(currentDateStr))) continue;

                for (const existingTask of allTasks) {
                    if (existingTask.id === ignoreTaskId) continue;
                    if (existingTask.status === 'completed' && !existingTask.isRecurring) continue;
                    if (!existingTask.startTime) continue;

                    let existingTaskIsInstanceOnThisDay = false;
                    if (existingTask.isRecurring && existingTask.recurrenceStartDate) {
                        const exRecStartDate = new Date(existingTask.recurrenceStartDate + "T00:00:00");
                        if (existingTask.recurrenceEndDate && currentDateToCheck > new Date(existingTask.recurrenceEndDate + "T23:59:59")) continue;
                        if (existingTask.skippedDates && existingTask.skippedDates.includes(currentDateStr)) continue;

                         if (currentDateToCheck >= exRecStartDate) {
                            if (existingTask.recurrenceType === 'specific_days_of_week' && existingTask.recurrenceDaysOfWeek && existingTask.recurrenceDaysOfWeek.includes(currentDayOfWeek)) {
                                existingTaskIsInstanceOnThisDay = true;
                            } else if (existingTask.recurrenceType === 'every_x_days' && existingTask.recurrenceInterval > 0) {
                                const diffTime = currentDateToCheck.getTime() - exRecStartDate.getTime();
                                const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
                                if (diffDays >= 0 && diffDays % existingTask.recurrenceInterval === 0) existingTaskIsInstanceOnThisDay = true;
                            }
                        }
                    } else if(!existingTask.isRecurring) {
                        if (existingTask.dueDate === currentDateStr) existingTaskIsInstanceOnThisDay = true;
                    }
                    if (!existingTaskIsInstanceOnThisDay || (existingTask.isRecurring && existingTask.completedDates && existingTask.completedDates.includes(currentDateStr))) continue;
                    
                    if (taskDataIsInstanceOnThisDay && existingTaskIsInstanceOnThisDay) {
                        if (checkOverlapOnDate(currentDateStr, taskData.startTime, taskData.estimatedTime, existingTask.startTime, existingTask.estimatedTime)) {
                            if (!conflicts.some(c => c.id === existingTask.id && c.conflictDate === currentDateStr)) {
                                conflicts.push({ ...existingTask, conflictDate: currentDateStr, conflictingNewTaskTitle: taskData.title });
                            }
                        }
                    }
                }
            }
            return [...new Map(conflicts.map(item => [item.id + "_" + item.conflictDate, item])).values()]; 
        }


        // --- Lógica de Configuração de Expediente ---
        // ... (sem alterações) ...
        const daysOfWeek = ["Domingo", "Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado"]; 
        function renderWorkHoursInputs(config = {}) { 
            workHoursInputsContainer.innerHTML = '';
            daysOfWeek.forEach((dayName, dayIndex) => { 
                const dayConfig = config[dayIndex] || {}; 
                const dayDiv = document.createElement('div');
                dayDiv.className = 'p-3 bg-gray-700 rounded-md';
                dayDiv.innerHTML = `
                    <p class="font-medium text-gray-200 mb-2">${dayName}</p>
                    <div class="grid grid-cols-2 sm:grid-cols-4 gap-x-3 gap-y-2 text-sm">
                        <div><label for="mStart_${dayIndex}" class="block text-gray-400">Manhã Início</label><input type="time" id="mStart_${dayIndex}" data-day="${dayIndex}" data-period="morningStart" value="${dayConfig.morningStart || ''}" class="mt-1 w-full bg-gray-600 border-gray-500 rounded-md py-1 px-2 text-white focus:ring-teal-500 focus:border-teal-500"></div>
                        <div><label for="mEnd_${dayIndex}" class="block text-gray-400">Manhã Fim</label><input type="time" id="mEnd_${dayIndex}" data-day="${dayIndex}" data-period="morningEnd" value="${dayConfig.morningEnd || ''}" class="mt-1 w-full bg-gray-600 border-gray-500 rounded-md py-1 px-2 text-white focus:ring-teal-500 focus:border-teal-500"></div>
                        <div><label for="aStart_${dayIndex}" class="block text-gray-400">Tarde Início</label><input type="time" id="aStart_${dayIndex}" data-day="${dayIndex}" data-period="afternoonStart" value="${dayConfig.afternoonStart || ''}" class="mt-1 w-full bg-gray-600 border-gray-500 rounded-md py-1 px-2 text-white focus:ring-teal-500 focus:border-teal-500"></div>
                        <div><label for="aEnd_${dayIndex}" class="block text-gray-400">Tarde Fim</label><input type="time" id="aEnd_${dayIndex}" data-day="${dayIndex}" data-period="afternoonEnd" value="${dayConfig.afternoonEnd || ''}" class="mt-1 w-full bg-gray-600 border-gray-500 rounded-md py-1 px-2 text-white focus:ring-teal-500 focus:border-teal-500"></div>
                    </div>`;
                workHoursInputsContainer.appendChild(dayDiv);
            });
        }
        async function loadWorkHours() { 
            if (!workHoursConfigRef) { return; } if (unsubscribeWorkHours) unsubscribeWorkHours();
            unsubscribeWorkHours = onSnapshot(workHoursConfigRef, (docSnap) => {
                userWorkHours = docSnap.exists() ? docSnap.data() : {}; 
                renderWorkHoursInputs(userWorkHours);
            }, (error) => { console.error("Erro carregar expediente:", error); showToast("Erro carregar expediente.", "error"); });
        }
        workHoursForm.addEventListener('submit', async (e) => { 
            e.preventDefault(); if (!workHoursConfigRef) return; showLoadingIndicator();
            const newCfg = {}; workHoursInputsContainer.querySelectorAll('input[type="time"]').forEach(i => {
                const d=i.dataset.day; const p=i.dataset.period; if(!newCfg[d])newCfg[d]={}; newCfg[d][p]=i.value||null;});
            try { await setDoc(workHoursConfigRef, newCfg); showToast("Expediente salvo!", "success"); workHoursModal.classList.add('hidden');
            } catch (err) { console.error("Erro salvar expediente:", err); showToast("Erro salvar expediente.", "error");
            } finally { showLoadingIndicator(false); }
        });
        openWorkHoursModalButton.addEventListener('click', () => workHoursModal.classList.remove('hidden'));
        closeWorkHoursModalButton.addEventListener('click', () => workHoursModal.classList.add('hidden'));


        // --- "Suggest Time" Logic ---
        function findNextAvailableSlot(taskDurationMinutes, forEditingTask = null) { /* ... (atualizado para every_x_days) ... */
            const slotIncrementMinutes = 15;
            const maxDaysToSearch = 30; 
            let searchStartMoment = new Date(); 
            searchStartMoment.setSeconds(0, 0);
            searchStartMoment.setMinutes(Math.ceil(searchStartMoment.getMinutes() / slotIncrementMinutes) * slotIncrementMinutes);

            const formIsRecurring = forEditingTask ? forEditingTask.isRecurring : taskIsRecurringCheckbox.checked;
            const formRecurrenceType = forEditingTask ? forEditingTask.recurrenceType : taskRecurrenceTypeSelect.value;
            const formRecurrenceStartDateStr = forEditingTask ? forEditingTask.recurrenceStartDate : taskRecurrenceStartDateInput.value;
            const formRecurrenceDays = forEditingTask ? (forEditingTask.recurrenceDaysOfWeek || []) : Array.from(taskRecurrenceDaysOfWeekDiv.querySelectorAll('input[type="checkbox"]:checked')).map(cb => parseInt(cb.value));
            const formRecurrenceInterval = forEditingTask ? forEditingTask.recurrenceInterval : parseInt(taskRecurrenceIntervalInput.value);
            const formDueDateStr = forEditingTask ? forEditingTask.dueDate : taskDueDateInput.value;

            if (formIsRecurring && formRecurrenceStartDateStr) {
                const recStartDate = new Date(formRecurrenceStartDateStr + "T00:00:00");
                if (recStartDate > searchStartMoment) { 
                    searchStartMoment = new Date(recStartDate);
                }
            } else if (!formIsRecurring && formDueDateStr) { 
                const dueDate = new Date(formDueDateStr + "T00:00:00");
                searchStartMoment = (dueDate >= new Date().setHours(0,0,0,0)) ? dueDate : new Date();
                searchStartMoment.setSeconds(0,0);
                searchStartMoment.setMinutes(Math.ceil(searchStartMoment.getMinutes() / slotIncrementMinutes) * slotIncrementMinutes);
            }


            for (let dayOffset = 0; dayOffset < maxDaysToSearch; dayOffset++) {
                let currentDateToTest = new Date(searchStartMoment);
                currentDateToTest.setDate(searchStartMoment.getDate() + dayOffset);
                currentDateToTest.setHours(0,0,0,0); 

                const dayOfWeek = currentDateToTest.getDay();
                let isPotentialDayForTask = false;

                if (formIsRecurring) {
                    const recStartDate = new Date(formRecurrenceStartDateStr + "T00:00:00");
                    if (currentDateToTest >= recStartDate) {
                        if (formRecurrenceType === 'specific_days_of_week' && formRecurrenceDays.includes(dayOfWeek)) {
                            isPotentialDayForTask = true;
                        } else if (formRecurrenceType === 'every_x_days' && formRecurrenceInterval > 0) {
                            const diffTime = currentDateToTest.getTime() - recStartDate.getTime();
                            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
                            if (diffDays >= 0 && diffDays % formRecurrenceInterval === 0) isPotentialDayForTask = true;
                        }
                    }
                } else { 
                    if (currentDateToTest.toISOString().split('T')[0] === (formDueDateStr || new Date().toISOString().split('T')[0])) {
                         isPotentialDayForTask = true;
                    }
                    if(formDueDateStr && currentDateToTest.toISOString().split('T')[0] !== formDueDateStr) continue;
                }
                if (!isPotentialDayForTask) continue;

                const workDayConfig = userWorkHours[dayOfWeek];
                if (workDayConfig) {
                    const periods = [];
                    if (workDayConfig.morningStart && workDayConfig.morningEnd) periods.push({ start: workDayConfig.morningStart, end: workDayConfig.morningEnd });
                    if (workDayConfig.afternoonStart && workDayConfig.afternoonEnd) periods.push({ start: workDayConfig.afternoonStart, end: workDayConfig.afternoonEnd });

                    for (const period of periods) {
                        let periodTestStartTime = new Date(currentDateToTest.toDateString() + " " + period.start);
                        const periodActualEndTime = new Date(currentDateToTest.toDateString() + " " + period.end);

                        if (currentDateToTest.toDateString() === new Date().toDateString() && periodTestStartTime < new Date()) {
                             periodTestStartTime = new Date(); 
                             periodTestStartTime.setSeconds(0,0);
                             periodTestStartTime.setMinutes(Math.ceil(periodTestStartTime.getMinutes() / slotIncrementMinutes) * slotIncrementMinutes);
                        }
                        if (periodTestStartTime >= periodActualEndTime) continue;


                        while (periodTestStartTime < periodActualEndTime) {
                            const potentialSlotEnd = new Date(periodTestStartTime.getTime() + taskDurationMinutes * 60000);
                            if (potentialSlotEnd > periodActualEndTime) break;

                            const tempTaskDataForCheck = {
                                dueDate: formIsRecurring ? null : currentDateToTest.toISOString().split('T')[0],
                                startTime: `${String(periodTestStartTime.getHours()).padStart(2, '0')}:${String(periodTestStartTime.getMinutes()).padStart(2, '0')}`,
                                estimatedTime: taskDurationMinutes,
                                isRecurring: formIsRecurring,
                                recurrenceType: formIsRecurring ? formRecurrenceType : null,
                                recurrenceDaysOfWeek: formIsRecurring && formRecurrenceType === 'specific_days_of_week' ? formRecurrenceDays : null,
                                recurrenceInterval: formIsRecurring && formRecurrenceType === 'every_x_days' ? formRecurrenceInterval : null,
                                recurrenceStartDate: formIsRecurring ? formRecurrenceStartDateStr : null,
                                _instanceDateForConflictCheck: currentDateToTest.toISOString().split('T')[0] 
                            };
                            
                            const conflicts = checkConflictsSync(tempTaskDataForCheck, allUserTasks, forEditingTask ? forEditingTask.id : null);
                            if (conflicts.length === 0) {
                                return { date: currentDateToTest.toISOString().split('T')[0], time: tempTaskDataForCheck.startTime };
                            }
                            periodTestStartTime.setMinutes(periodTestStartTime.getMinutes() + slotIncrementMinutes);
                        }
                    }
                }
                if (!formIsRecurring && (formDueDateStr || dayOffset === 0)) break;
            }
            return null; 
        }
        function checkConflictsSync(taskData, allTasks, ignoreTaskId = null) { /* ... (atualizado para every_x_days) ... */
            const conflicts = [];
            if (!taskData.startTime) return conflicts;

            const dateToCheckStr = taskData._instanceDateForConflictCheck || (taskData.isRecurring ? taskData.recurrenceStartDate : taskData.dueDate);
            
            if (!dateToCheckStr) {
                 console.warn("checkConflictsSync: Data para checagem não definida.", taskData);
                 return conflicts; 
            }
            
            const taskStart = new Date(`${dateToCheckStr}T${taskData.startTime}`);
            const taskEnd = new Date(taskStart.getTime() + taskData.estimatedTime * 60000);

            for (const existingTask of allTasks) {
                if (existingTask.id === ignoreTaskId) continue;
                if (existingTask.status === 'completed' && !existingTask.isRecurring) continue; 
                if (!existingTask.startTime) continue;

                let isExistingInstanceOnThisDate = false;
                if (existingTask.isRecurring && existingTask.recurrenceStartDate) {
                    const exRecStart = new Date(existingTask.recurrenceStartDate + "T00:00:00");
                    const dateToCheckObj = new Date(dateToCheckStr + "T00:00:00");

                    if (existingTask.recurrenceEndDate && dateToCheckObj > new Date(existingTask.recurrenceEndDate + "T23:59:59")) continue; 
                    if (existingTask.skippedDates && existingTask.skippedDates.includes(dateToCheckStr)) continue; 


                    if (dateToCheckObj >= exRecStart) {
                        if (existingTask.recurrenceType === 'specific_days_of_week' && existingTask.recurrenceDaysOfWeek && existingTask.recurrenceDaysOfWeek.includes(dateToCheckObj.getDay())) {
                            isExistingInstanceOnThisDate = true;
                        } else if (existingTask.recurrenceType === 'every_x_days' && existingTask.recurrenceInterval > 0) {
                            const diffTime = dateToCheckObj.getTime() - exRecStart.getTime();
                            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
                            if (diffDays >= 0 && diffDays % existingTask.recurrenceInterval === 0) isExistingInstanceOnThisDate = true;
                        }
                    }
                    if (isExistingInstanceOnThisDate && existingTask.completedDates && existingTask.completedDates.includes(dateToCheckStr)) {
                        isExistingInstanceOnThisDate = false; 
                    }
                } else if (!existingTask.isRecurring && existingTask.dueDate === dateToCheckStr) {
                    isExistingInstanceOnThisDate = true;
                }

                if (isExistingInstanceOnThisDate) {
                    const existingInstanceStart = new Date(`${dateToCheckStr}T${existingTask.startTime}`);
                    const existingInstanceEnd = new Date(existingInstanceStart.getTime() + (existingTask.estimatedTime * 60000));
                    if (taskStart < existingInstanceEnd && taskEnd > existingInstanceStart) {
                        conflicts.push(existingTask);
                    }
                }
            }
            return conflicts;
        }

        suggestTimeButton.addEventListener('click', () => {
            const duration = parseInt(taskEstimatedTimeInput.value);
            if (!duration || duration <= 0) { showToast("Insira tempo estimado.", "error"); return; }
            const slot = findNextAvailableSlot(duration);
            if (slot) {
                if (taskIsRecurringCheckbox.checked) taskRecurrenceStartDateInput.value = slot.date;
                else taskDueDateInput.value = slot.date;
                taskStartTimeInput.value = slot.time;
                showToast(`Sugerido: ${slot.time} em ${new Date(slot.date+'T00:00:00').toLocaleDateString('pt-BR')}`, 'info');
            } else { showToast("Nenhum horário encontrado.", "info", 6000); }
        });
        editSuggestTimeButton.addEventListener('click', () => {
            const duration = parseInt(editTaskEstimatedTimeInput.value);
            const taskId = editTaskIdInput.value; const taskBeingEdited = allUserTasks.find(t => t.id === taskId);
            if (!duration || duration <= 0) { showToast("Insira tempo estimado.", "error"); return; }
            const slot = findNextAvailableSlot(duration, taskBeingEdited);
            if (slot) {
                if (editTaskIsRecurringCheckbox.checked) editTaskRecurrenceStartDateInput.value = slot.date;
                else editTaskDueDateInput.value = slot.date;
                editTaskStartTimeInput.value = slot.time;
                showToast(`Sugerido: ${slot.time} em ${new Date(slot.date+'T00:00:00').toLocaleDateString('pt-BR')}`, 'info');
            } else { showToast("Nenhum horário encontrado.", "info", 6000); }
        });


        // --- Daily Task "Create One-Off Instance for Today" ---
        createOneOffInstanceButton.addEventListener('click', async () => { /* ... (sem alterações) ... */
            const originalTaskId = editTaskIdInput.value;
            const originalTask = allUserTasks.find(t => t.id === originalTaskId);
            if (!originalTask || !originalTask.isRecurring) { showToast("Opção para tarefas recorrentes.", "error"); return; }
            
            const newTitle = prompt("Título para a instância de hoje:", originalTask.title);
            const newStartTime = prompt("Nova hora de início para hoje (HH:MM):", originalTask.startTime);
            const newEstimatedTime = parseInt(prompt("Novo tempo estimado para hoje (minutos):", originalTask.estimatedTime));

            if (!newStartTime || !newEstimatedTime || newEstimatedTime <=0) { showToast("Hora e tempo válidos são obrigatórios.", "error"); return; }
            
            const todayStr = new Date().toISOString().split('T')[0];
            const newTaskData = {
                ...originalTask, title: newTitle || originalTask.title, isRecurring: false, 
                recurrenceType: null, recurrenceDaysOfWeek: null, recurrenceStartDate: null, recurrenceInterval: null, recurrenceEndDate: null,
                dueDate: todayStr, startTime: newStartTime, estimatedTime: newEstimatedTime, originalEstimatedTime: newEstimatedTime,
                status: 'pending', remainingSeconds: newEstimatedTime * 60, lastStartTime: null,
                timeTrackedSeconds: 0, isTrackingTime: false, lastTrackingStartTime: null, // Resetar cronômetro para nova instância
                createdAt: serverTimestamp(), updatedAt: serverTimestamp(), completedDates: [], skippedDates: [],
                originalRecurringTaskId: originalTask.id 
            };
            delete newTaskData.id; 

            showLoadingIndicator();
            const conflicts = await checkConflicts(newTaskData, allUserTasks);
            if (conflicts.length > 0) {
                showToast(`Conflito para instância de hoje: ${conflicts.map(c=>c.title).join(',')}.`, 'error', 7000);
                showLoadingIndicator(false); return;
            }

            try {
                await addDoc(tasksCollectionRef, newTaskData);
                const originalTaskRef = doc(tasksCollectionRef, originalTask.id);
                const updatedCompletedDates = Array.isArray(originalTask.completedDates) ? [...originalTask.completedDates] : [];
                if (!updatedCompletedDates.includes(todayStr)) updatedCompletedDates.push(todayStr);
                const updatedSkippedDates = Array.isArray(originalTask.skippedDates) ? [...originalTask.skippedDates] : [];
                if (!updatedSkippedDates.includes(todayStr)) updatedSkippedDates.push(todayStr);

                await updateDoc(originalTaskRef, { completedDates: updatedCompletedDates, skippedDates: updatedSkippedDates, updatedAt: serverTimestamp() });
                showToast("Instância de hoje criada; original marcada como concluída/pulada hoje.", "success");
                editTaskModal.classList.add('hidden');
            } catch (error) { console.error("Erro recriar instância:", error); showToast("Erro ao recriar.", "error");
            } finally { showLoadingIndicator(false); }
        });


        // --- Troca de Visualização (Lista/Calendário) ---
         function toggleView(view) { /* ... (sem alterações) ... */
            currentView = view;
            taskListContainer.classList.toggle('hidden', view !== 'list');
            calendarContainer.classList.toggle('hidden', view !== 'calendar');
            completedTasksSection.classList.toggle('hidden', view !== 'list'); 

            viewToggleListButton.classList.toggle('bg-indigo-600', view === 'list');
            viewToggleListButton.classList.toggle('bg-gray-600', view !== 'list');
            viewToggleListButton.classList.toggle('hover:bg-gray-500', view !== 'list');
            viewToggleCalendarButton.classList.toggle('bg-indigo-600', view === 'calendar');
            viewToggleCalendarButton.classList.toggle('bg-gray-600', view !== 'calendar');
            viewToggleCalendarButton.classList.toggle('hover:bg-gray-500', view !== 'calendar');
            if (view === 'calendar' && calendar) calendar.render();
            applyFiltersAndRenderTasks(); 
        }
        viewToggleListButton.addEventListener('click', () => toggleView('list'));
        viewToggleCalendarButton.addEventListener('click', () => toggleView('calendar'));


        // --- Ações Rápidas do Calendário ---
        function showCalendarEventQuickActions(jsEvent, taskData, instanceDate) {
            if (!calendarEventQuickActionsPopup || !quickActionTaskTitle || !quickActionStartEstimatedButton || !quickActionPauseEstimatedButton || !quickActionResumeEstimatedButton || !quickActionStartTrackingButton || !quickActionStopTrackingButton || !quickActionCompleteTaskButton || !quickActionEditTaskButton || !quickActionDeleteTaskButton) {
                console.error("Um ou mais elementos do pop-up de ações rápidas não foram encontrados no DOM.");
                return;
            }
            quickActionTaskTitle.textContent = taskData.title;
            quickActionTaskTitle.title = taskData.title;

            let effectiveStatus = taskData.status;
            const todayStr = new Date().toISOString().split('T')[0];
            const isInstanceCompleted = taskData.isRecurring && taskData.completedDates && taskData.completedDates.includes(instanceDate);
            const isInstanceSkipped = taskData.isRecurring && taskData.skippedDates && taskData.skippedDates.includes(instanceDate);

            if (isInstanceCompleted) {
                effectiveStatus = 'completed';
            } else if (isInstanceSkipped) {
                effectiveStatus = 'skipped'; 
            } else if (!taskData.isRecurring && taskData.dueDate < todayStr && taskData.status !== 'completed') {
                effectiveStatus = 'overdue';
            } else if (taskData.isRecurring && instanceDate < todayStr && taskData.status !== 'completed' && !isInstanceCompleted) {
                 effectiveStatus = 'overdue'; 
            }

            quickActionStartEstimatedButton.classList.toggle('hidden', !(effectiveStatus === 'pending' || effectiveStatus === 'overdue' || effectiveStatus === 'skipped'));
            quickActionPauseEstimatedButton.classList.toggle('hidden', effectiveStatus !== 'in-progress');
            quickActionResumeEstimatedButton.classList.toggle('hidden', effectiveStatus !== 'paused');

            quickActionStartTrackingButton.classList.toggle('hidden', taskData.isTrackingTime || effectiveStatus === 'completed' || effectiveStatus === 'skipped');
            quickActionStopTrackingButton.classList.toggle('hidden', !taskData.isTrackingTime);
            
            quickActionCompleteTaskButton.classList.toggle('hidden', effectiveStatus === 'completed' || effectiveStatus === 'skipped');

            const cloneAndReplace = (button) => {
                let newButton = button.cloneNode(true);
                if(button.parentNode) { 
                   button.parentNode.replaceChild(newButton, button);
                }
                return newButton;
            };

            quickActionStartEstimatedButton = cloneAndReplace(quickActionStartEstimatedButton);
            quickActionPauseEstimatedButton = cloneAndReplace(quickActionPauseEstimatedButton);
            quickActionResumeEstimatedButton = cloneAndReplace(quickActionResumeEstimatedButton);
            quickActionStartTrackingButton = cloneAndReplace(quickActionStartTrackingButton);
            quickActionStopTrackingButton = cloneAndReplace(quickActionStopTrackingButton);
            quickActionCompleteTaskButton = cloneAndReplace(quickActionCompleteTaskButton);
            quickActionEditTaskButton = cloneAndReplace(quickActionEditTaskButton);
            quickActionDeleteTaskButton = cloneAndReplace(quickActionDeleteTaskButton);

            quickActionStartEstimatedButton.onclick = () => { handleTaskAction(taskData.id, 'start', instanceDate); hideCalendarEventQuickActions(); };
            quickActionPauseEstimatedButton.onclick = () => { handleTaskAction(taskData.id, 'pause', instanceDate); hideCalendarEventQuickActions(); };
            quickActionResumeEstimatedButton.onclick = () => { handleTaskAction(taskData.id, 'resume', instanceDate); hideCalendarEventQuickActions(); };
            quickActionStartTrackingButton.onclick = () => { handleTimeTracking(taskData.id, 'start_manual_tracking', instanceDate); hideCalendarEventQuickActions(); };
            quickActionStopTrackingButton.onclick = () => { handleTimeTracking(taskData.id, 'stop_manual_tracking', instanceDate); hideCalendarEventQuickActions(); };
            quickActionCompleteTaskButton.onclick = () => { handleTaskAction(taskData.id, 'complete', instanceDate); hideCalendarEventQuickActions(); };
            quickActionEditTaskButton.onclick = () => { openEditModalWithTask(taskData, instanceDate); hideCalendarEventQuickActions(); };
            quickActionDeleteTaskButton.onclick = () => {
                taskToDeleteId = taskData.id;
                instanceDateToDelete = instanceDate; 
                if (taskData.isRecurring) {
                    deleteThisInstanceButton.dataset.instanceDate = instanceDate;
                    deleteFutureInstancesButton.dataset.instanceDate = instanceDate;
                    deleteRecurrenceOptionsModal.classList.remove('hidden');
                } else {
                    openConfirmationModal('Excluir Tarefa', 'Tem certeza?', () => deleteTask(taskData.id));
                }
                hideCalendarEventQuickActions();
            };
            
            const eventElement = jsEvent.target.closest('.fc-event');
            if (!eventElement) return; 
            const rect = eventElement.getBoundingClientRect();

            let left = rect.left + window.scrollX;
            let top = rect.bottom + window.scrollY + 5;

            calendarEventQuickActionsPopup.style.left = `${left}px`;
            calendarEventQuickActionsPopup.style.top = `${top}px`;
            calendarEventQuickActionsPopup.classList.remove('hidden');

            const popupRect = calendarEventQuickActionsPopup.getBoundingClientRect();
            if (popupRect.right > window.innerWidth) {
                calendarEventQuickActionsPopup.style.left = `${window.innerWidth - popupRect.width - 10 + window.scrollX}px`;
            }
            if (popupRect.bottom > window.innerHeight) {
                calendarEventQuickActionsPopup.style.top = `${rect.top + window.scrollY - popupRect.height - 5}px`;
            }
        }

        function hideCalendarEventQuickActions() {
            if(calendarEventQuickActionsPopup) calendarEventQuickActionsPopup.classList.add('hidden');
        }

        document.addEventListener('click', function(event) {
            if (calendarEventQuickActionsPopup && !calendarEventQuickActionsPopup.classList.contains('hidden')) {
                const isClickInsidePopup = calendarEventQuickActionsPopup.contains(event.target);
                const isClickOnCalendarEvent = event.target.closest('.fc-event'); 

                if (!isClickInsidePopup && !isClickOnCalendarEvent) {
                    hideCalendarEventQuickActions();
                }
            }
        });


        // --- Setup de Event Listeners Adicionais ---
        function setupEventListeners() { 
             taskIsRecurringCheckbox.dispatchEvent(new Event('change')); 
             editTaskIsRecurringCheckbox.dispatchEvent(new Event('change')); 
             taskRecurrenceTypeSelect.dispatchEvent(new Event('change'));
             editTaskRecurrenceTypeSelect.dispatchEvent(new Event('change'));
             toggleView('list'); // Começa com a visualização de lista
             applyFiltersAndRenderTasks(); // Renderiza tarefas para a data inicial (hoje)
        }
    </script>
</body>
</html>
